/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
    "mutation IngestArtifact($artifact: ArtifactInputSpec!) {\n  ingestArtifact(artifact: $artifact) {\n    ...AllArtifactTree\n  }\n}\n\nmutation IngestArtifacts($artifacts: [ArtifactInputSpec!]!) {\n  ingestArtifacts(artifacts: $artifacts) {\n    ...AllArtifactTree\n  }\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}": types.IngestArtifactDocument,
    "mutation IngestBuilder($builder: BuilderInputSpec!) {\n  ingestBuilder(builder: $builder) {\n    uri\n  }\n}\n\nmutation IngestBuilders($builders: [BuilderInputSpec!]!) {\n  ingestBuilders(builders: $builders) {\n    uri\n  }\n}": types.IngestBuilderDocument,
    "mutation CertifyBadPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadSrc($source: SourceInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadArtifact($artifact: ArtifactInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadSrcs($sources: [SourceInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nquery CertifyBads($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}": types.CertifyBadPkgDocument,
    "mutation CertifyGoodPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodSrc($source: SourceInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodArtifact($artifact: ArtifactInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodSrcs($sources: [SourceInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}": types.CertifyGoodPkgDocument,
    "mutation CertifyScorecard($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard) {\n    ...AllCertifyScorecard\n  }\n}\n\nmutation CertifyScorecards($sources: [SourceInputSpec!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards) {\n    ...AllCertifyScorecard\n  }\n}": types.CertifyScorecardDocument,
    "mutation VexPackageAndCve($pkg: PkgInputSpec!, $cve: CVEInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {cve: $cve}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VEXPackageAndGhsa($pkg: PkgInputSpec!, $ghsa: GHSAInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {ghsa: $ghsa}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexPackageAndOsv($pkg: PkgInputSpec!, $osv: OSVInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {osv: $osv}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndCve($artifact: ArtifactInputSpec!, $cve: CVEInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {cve: $cve}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndGhsa($artifact: ArtifactInputSpec!, $ghsa: GHSAInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {ghsa: $ghsa}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndOsv($artifact: ArtifactInputSpec!, $osv: OSVInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {osv: $osv}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}": types.VexPackageAndCveDocument,
    "mutation CertifyOSV($pkg: PkgInputSpec!, $osv: OSVInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {osv: $osv}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyCVE($pkg: PkgInputSpec!, $cve: CVEInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {cve: $cve}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyGHSA($pkg: PkgInputSpec!, $ghsa: GHSAInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {ghsa: $ghsa}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyNoKnownVuln($pkg: PkgInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {noVuln: true}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}": types.CertifyOsvDocument,
    "mutation PointOfContactPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}\n\nmutation PointOfContactSrc($source: SourceInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}\n\nmutation PointOfContactArtifact($artifact: ArtifactInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}": types.PointOfContactPkgDocument,
    "mutation IngestCVE($cve: CVEInputSpec!) {\n  ingestCVE(cve: $cve) {\n    ...AllCveTree\n  }\n}\n\nmutation IngestCVEs($cves: [CVEInputSpec!]!) {\n  ingestCVEs(cves: $cves) {\n    ...AllCveTree\n  }\n}\n\nquery CVEs($filter: CVESpec!) {\n  cve(cveSpec: $filter) {\n    ...AllCveTree\n  }\n}": types.IngestCveDocument,
    "mutation IngestGHSA($ghsa: GHSAInputSpec!) {\n  ingestGHSA(ghsa: $ghsa) {\n    ...AllGHSATree\n  }\n}\n\nmutation IngestGHSAs($ghsas: [GHSAInputSpec!]!) {\n  ingestGHSAs(ghsas: $ghsas) {\n    ...AllGHSATree\n  }\n}\n\nquery GHSAs($filter: GHSASpec!) {\n  ghsa(ghsaSpec: $filter) {\n    ...AllGHSATree\n  }\n}": types.IngestGhsaDocument,
    "mutation HasSBOMPkg($pkg: PkgInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMArtifact($artifact: ArtifactInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {artifact: $artifact}, hasSBOM: $hasSBOM) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMPkgs($pkgs: [PkgInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {packages: $pkgs}, hasSBOMs: $hasSBOMs) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMArtifacts($artifacts: [ArtifactInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {artifacts: $artifacts}, hasSBOMs: $hasSBOMs) {\n    ...AllHasSBOMTree\n  }\n}": types.HasSbomPkgDocument,
    "mutation SLSAForArtifact($artifact: ArtifactInputSpec!, $materials: [ArtifactInputSpec!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  ) {\n    ...AllSLSATree\n  }\n}\n\nmutation SLSAForArtifacts($artifacts: [ArtifactInputSpec!]!, $materialsList: [[ArtifactInputSpec!]!]!, $builders: [BuilderInputSpec!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  ) {\n    ...AllSLSATree\n  }\n}": types.SlsaForArtifactDocument,
    "mutation HasSourceAt($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $source: SourceInputSpec!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  ) {\n    ...AllHasSourceAt\n  }\n}": types.HasSourceAtDocument,
    "mutation HashEqual($artifact: ArtifactInputSpec!, $otherArtifact: ArtifactInputSpec!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  ) {\n    ...AllHashEqualTree\n  }\n}\n\nmutation HashEquals($artifacts: [ArtifactInputSpec!]!, $otherArtifacts: [ArtifactInputSpec!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  ) {\n    ...AllHashEqualTree\n  }\n}": types.HashEqualDocument,
    "mutation IsDependency($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency) {\n    ...AllIsDependencyTree\n  }\n}\n\nmutation IsDependencies($pkgs: [PkgInputSpec!]!, $depPkgs: [PkgInputSpec!]!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(pkgs: $pkgs, depPkgs: $depPkgs, dependencies: $dependencies) {\n    ...AllIsDependencyTree\n  }\n}": types.IsDependencyDocument,
    "mutation IsOccurrencePkg($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrenceSrc($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrencesPkg($pkgs: [PkgInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrencesSrc($sources: [SourceInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}": types.IsOccurrencePkgDocument,
    "mutation IsVulnerabilityCVE($osv: OSVInputSpec!, $cve: CVEInputSpec!, $isVulnerability: IsVulnerabilityInputSpec!) {\n  ingestIsVulnerability(\n    osv: $osv\n    vulnerability: {cve: $cve}\n    isVulnerability: $isVulnerability\n  ) {\n    ...AllIsVulnerability\n  }\n}\n\nmutation IsVulnerabilityGHSA($osv: OSVInputSpec!, $ghsa: GHSAInputSpec!, $isVulnerability: IsVulnerabilityInputSpec!) {\n  ingestIsVulnerability(\n    osv: $osv\n    vulnerability: {ghsa: $ghsa}\n    isVulnerability: $isVulnerability\n  ) {\n    ...AllIsVulnerability\n  }\n}": types.IsVulnerabilityCveDocument,
    "mutation HasMetadataPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}\n\nmutation HasMetadataSrc($source: SourceInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}\n\nmutation HasMetadataArtifact($artifact: ArtifactInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}": types.HasMetadataPkgDocument,
    "mutation IngestOSV($osv: OSVInputSpec!) {\n  ingestOSV(osv: $osv) {\n    ...AllOSVTree\n  }\n}\n\nmutation IngestOSVs($osvs: [OSVInputSpec!]!) {\n  ingestOSVs(osvs: $osvs) {\n    ...AllOSVTree\n  }\n}\n\nquery OSVs($filter: OSVSpec!) {\n  osv(osvSpec: $filter) {\n    ...AllOSVTree\n  }\n}": types.IngestOsvDocument,
    "mutation IngestPackage($pkg: PkgInputSpec!) {\n  ingestPackage(pkg: $pkg) {\n    ...AllPkgTree\n  }\n}\n\nmutation IngestPackages($pkgs: [PkgInputSpec!]!) {\n  ingestPackages(pkgs: $pkgs) {\n    ...AllPkgTree\n  }\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n      names {\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n      names {\n        name\n        versions {\n          version\n          qualifiers {\n            key\n            value\n          }\n        }\n      }\n    }\n  }\n}": types.IngestPackageDocument,
    "query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}": types.PathDocument,
    "mutation PkgEqual($pkg: PkgInputSpec!, $otherPackage: PkgInputSpec!, $pkgEqual: PkgEqualInputSpec!) {\n  pkg: ingestPackage(pkg: $pkg) {\n    ...AllPkgTree\n  }\n  otherPackage: ingestPackage(pkg: $otherPackage) {\n    ...AllPkgTree\n  }\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual) {\n    ...AllPkgEqual\n  }\n}": types.PkgEqualDocument,
    "query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}": types.FindSoftwareDocument,
    "mutation IngestSource($source: SourceInputSpec!) {\n  ingestSource(source: $source) {\n    ...AllSourceTree\n  }\n}\n\nmutation IngestSources($sources: [SourceInputSpec!]!) {\n  ingestSources(sources: $sources) {\n    ...AllSourceTree\n  }\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}": types.IngestSourceDocument,
    "fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllCveTree on CVE {\n  id\n  year\n  cveId\n}\n\nfragment AllGHSATree on GHSA {\n  id\n  ghsaId\n}\n\nfragment AllOSVTree on OSV {\n  id\n  osvId\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependentPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  versionRange\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllIsVulnerability on IsVulnerability {\n  id\n  osv {\n    ...AllOSVTree\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}": types.AllPkgTreeFragmentDoc,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestArtifact($artifact: ArtifactInputSpec!) {\n  ingestArtifact(artifact: $artifact) {\n    ...AllArtifactTree\n  }\n}\n\nmutation IngestArtifacts($artifacts: [ArtifactInputSpec!]!) {\n  ingestArtifacts(artifacts: $artifacts) {\n    ...AllArtifactTree\n  }\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}"): (typeof documents)["mutation IngestArtifact($artifact: ArtifactInputSpec!) {\n  ingestArtifact(artifact: $artifact) {\n    ...AllArtifactTree\n  }\n}\n\nmutation IngestArtifacts($artifacts: [ArtifactInputSpec!]!) {\n  ingestArtifacts(artifacts: $artifacts) {\n    ...AllArtifactTree\n  }\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestBuilder($builder: BuilderInputSpec!) {\n  ingestBuilder(builder: $builder) {\n    uri\n  }\n}\n\nmutation IngestBuilders($builders: [BuilderInputSpec!]!) {\n  ingestBuilders(builders: $builders) {\n    uri\n  }\n}"): (typeof documents)["mutation IngestBuilder($builder: BuilderInputSpec!) {\n  ingestBuilder(builder: $builder) {\n    uri\n  }\n}\n\nmutation IngestBuilders($builders: [BuilderInputSpec!]!) {\n  ingestBuilders(builders: $builders) {\n    uri\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyBadPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadSrc($source: SourceInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadArtifact($artifact: ArtifactInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadSrcs($sources: [SourceInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nquery CertifyBads($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}"): (typeof documents)["mutation CertifyBadPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadSrc($source: SourceInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadArtifact($artifact: ArtifactInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadSrcs($sources: [SourceInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nmutation CertifyBadArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  ) {\n    ...AllCertifyBad\n  }\n}\n\nquery CertifyBads($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyGoodPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodSrc($source: SourceInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodArtifact($artifact: ArtifactInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodSrcs($sources: [SourceInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}"): (typeof documents)["mutation CertifyGoodPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodSrc($source: SourceInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodArtifact($artifact: ArtifactInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodSrcs($sources: [SourceInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}\n\nmutation CertifyGoodArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  ) {\n    ...AllCertifyGood\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyScorecard($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard) {\n    ...AllCertifyScorecard\n  }\n}\n\nmutation CertifyScorecards($sources: [SourceInputSpec!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards) {\n    ...AllCertifyScorecard\n  }\n}"): (typeof documents)["mutation CertifyScorecard($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard) {\n    ...AllCertifyScorecard\n  }\n}\n\nmutation CertifyScorecards($sources: [SourceInputSpec!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards) {\n    ...AllCertifyScorecard\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation VexPackageAndCve($pkg: PkgInputSpec!, $cve: CVEInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {cve: $cve}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VEXPackageAndGhsa($pkg: PkgInputSpec!, $ghsa: GHSAInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {ghsa: $ghsa}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexPackageAndOsv($pkg: PkgInputSpec!, $osv: OSVInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {osv: $osv}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndCve($artifact: ArtifactInputSpec!, $cve: CVEInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {cve: $cve}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndGhsa($artifact: ArtifactInputSpec!, $ghsa: GHSAInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {ghsa: $ghsa}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndOsv($artifact: ArtifactInputSpec!, $osv: OSVInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {osv: $osv}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}"): (typeof documents)["mutation VexPackageAndCve($pkg: PkgInputSpec!, $cve: CVEInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {cve: $cve}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VEXPackageAndGhsa($pkg: PkgInputSpec!, $ghsa: GHSAInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {ghsa: $ghsa}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexPackageAndOsv($pkg: PkgInputSpec!, $osv: OSVInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: {osv: $osv}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndCve($artifact: ArtifactInputSpec!, $cve: CVEInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {cve: $cve}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndGhsa($artifact: ArtifactInputSpec!, $ghsa: GHSAInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {ghsa: $ghsa}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nmutation VexArtifactAndOsv($artifact: ArtifactInputSpec!, $osv: OSVInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: {osv: $osv}\n    vexStatement: $vexStatement\n  ) {\n    ...AllCertifyVEXStatement\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyOSV($pkg: PkgInputSpec!, $osv: OSVInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {osv: $osv}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyCVE($pkg: PkgInputSpec!, $cve: CVEInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {cve: $cve}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyGHSA($pkg: PkgInputSpec!, $ghsa: GHSAInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {ghsa: $ghsa}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyNoKnownVuln($pkg: PkgInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {noVuln: true}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}"): (typeof documents)["mutation CertifyOSV($pkg: PkgInputSpec!, $osv: OSVInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {osv: $osv}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyCVE($pkg: PkgInputSpec!, $cve: CVEInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {cve: $cve}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyGHSA($pkg: PkgInputSpec!, $ghsa: GHSAInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {ghsa: $ghsa}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}\n\nmutation CertifyNoKnownVuln($pkg: PkgInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {\n  ingestVulnerability(\n    pkg: $pkg\n    vulnerability: {noVuln: true}\n    certifyVuln: $certifyVuln\n  ) {\n    ...AllCertifyVuln\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation PointOfContactPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}\n\nmutation PointOfContactSrc($source: SourceInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}\n\nmutation PointOfContactArtifact($artifact: ArtifactInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}"): (typeof documents)["mutation PointOfContactPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}\n\nmutation PointOfContactSrc($source: SourceInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}\n\nmutation PointOfContactArtifact($artifact: ArtifactInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  ) {\n    ...AllPointOfContact\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestCVE($cve: CVEInputSpec!) {\n  ingestCVE(cve: $cve) {\n    ...AllCveTree\n  }\n}\n\nmutation IngestCVEs($cves: [CVEInputSpec!]!) {\n  ingestCVEs(cves: $cves) {\n    ...AllCveTree\n  }\n}\n\nquery CVEs($filter: CVESpec!) {\n  cve(cveSpec: $filter) {\n    ...AllCveTree\n  }\n}"): (typeof documents)["mutation IngestCVE($cve: CVEInputSpec!) {\n  ingestCVE(cve: $cve) {\n    ...AllCveTree\n  }\n}\n\nmutation IngestCVEs($cves: [CVEInputSpec!]!) {\n  ingestCVEs(cves: $cves) {\n    ...AllCveTree\n  }\n}\n\nquery CVEs($filter: CVESpec!) {\n  cve(cveSpec: $filter) {\n    ...AllCveTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestGHSA($ghsa: GHSAInputSpec!) {\n  ingestGHSA(ghsa: $ghsa) {\n    ...AllGHSATree\n  }\n}\n\nmutation IngestGHSAs($ghsas: [GHSAInputSpec!]!) {\n  ingestGHSAs(ghsas: $ghsas) {\n    ...AllGHSATree\n  }\n}\n\nquery GHSAs($filter: GHSASpec!) {\n  ghsa(ghsaSpec: $filter) {\n    ...AllGHSATree\n  }\n}"): (typeof documents)["mutation IngestGHSA($ghsa: GHSAInputSpec!) {\n  ingestGHSA(ghsa: $ghsa) {\n    ...AllGHSATree\n  }\n}\n\nmutation IngestGHSAs($ghsas: [GHSAInputSpec!]!) {\n  ingestGHSAs(ghsas: $ghsas) {\n    ...AllGHSATree\n  }\n}\n\nquery GHSAs($filter: GHSASpec!) {\n  ghsa(ghsaSpec: $filter) {\n    ...AllGHSATree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation HasSBOMPkg($pkg: PkgInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMArtifact($artifact: ArtifactInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {artifact: $artifact}, hasSBOM: $hasSBOM) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMPkgs($pkgs: [PkgInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {packages: $pkgs}, hasSBOMs: $hasSBOMs) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMArtifacts($artifacts: [ArtifactInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {artifacts: $artifacts}, hasSBOMs: $hasSBOMs) {\n    ...AllHasSBOMTree\n  }\n}"): (typeof documents)["mutation HasSBOMPkg($pkg: PkgInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMArtifact($artifact: ArtifactInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {artifact: $artifact}, hasSBOM: $hasSBOM) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMPkgs($pkgs: [PkgInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {packages: $pkgs}, hasSBOMs: $hasSBOMs) {\n    ...AllHasSBOMTree\n  }\n}\n\nmutation HasSBOMArtifacts($artifacts: [ArtifactInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {artifacts: $artifacts}, hasSBOMs: $hasSBOMs) {\n    ...AllHasSBOMTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation SLSAForArtifact($artifact: ArtifactInputSpec!, $materials: [ArtifactInputSpec!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  ) {\n    ...AllSLSATree\n  }\n}\n\nmutation SLSAForArtifacts($artifacts: [ArtifactInputSpec!]!, $materialsList: [[ArtifactInputSpec!]!]!, $builders: [BuilderInputSpec!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  ) {\n    ...AllSLSATree\n  }\n}"): (typeof documents)["mutation SLSAForArtifact($artifact: ArtifactInputSpec!, $materials: [ArtifactInputSpec!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  ) {\n    ...AllSLSATree\n  }\n}\n\nmutation SLSAForArtifacts($artifacts: [ArtifactInputSpec!]!, $materialsList: [[ArtifactInputSpec!]!]!, $builders: [BuilderInputSpec!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  ) {\n    ...AllSLSATree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation HasSourceAt($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $source: SourceInputSpec!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  ) {\n    ...AllHasSourceAt\n  }\n}"): (typeof documents)["mutation HasSourceAt($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $source: SourceInputSpec!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  ) {\n    ...AllHasSourceAt\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation HashEqual($artifact: ArtifactInputSpec!, $otherArtifact: ArtifactInputSpec!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  ) {\n    ...AllHashEqualTree\n  }\n}\n\nmutation HashEquals($artifacts: [ArtifactInputSpec!]!, $otherArtifacts: [ArtifactInputSpec!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  ) {\n    ...AllHashEqualTree\n  }\n}"): (typeof documents)["mutation HashEqual($artifact: ArtifactInputSpec!, $otherArtifact: ArtifactInputSpec!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  ) {\n    ...AllHashEqualTree\n  }\n}\n\nmutation HashEquals($artifacts: [ArtifactInputSpec!]!, $otherArtifacts: [ArtifactInputSpec!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  ) {\n    ...AllHashEqualTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IsDependency($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency) {\n    ...AllIsDependencyTree\n  }\n}\n\nmutation IsDependencies($pkgs: [PkgInputSpec!]!, $depPkgs: [PkgInputSpec!]!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(pkgs: $pkgs, depPkgs: $depPkgs, dependencies: $dependencies) {\n    ...AllIsDependencyTree\n  }\n}"): (typeof documents)["mutation IsDependency($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency) {\n    ...AllIsDependencyTree\n  }\n}\n\nmutation IsDependencies($pkgs: [PkgInputSpec!]!, $depPkgs: [PkgInputSpec!]!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(pkgs: $pkgs, depPkgs: $depPkgs, dependencies: $dependencies) {\n    ...AllIsDependencyTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IsOccurrencePkg($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrenceSrc($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrencesPkg($pkgs: [PkgInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrencesSrc($sources: [SourceInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}"): (typeof documents)["mutation IsOccurrencePkg($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrenceSrc($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrencesPkg($pkgs: [PkgInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nmutation IsOccurrencesSrc($sources: [SourceInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  ) {\n    ...AllIsOccurrencesTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IsVulnerabilityCVE($osv: OSVInputSpec!, $cve: CVEInputSpec!, $isVulnerability: IsVulnerabilityInputSpec!) {\n  ingestIsVulnerability(\n    osv: $osv\n    vulnerability: {cve: $cve}\n    isVulnerability: $isVulnerability\n  ) {\n    ...AllIsVulnerability\n  }\n}\n\nmutation IsVulnerabilityGHSA($osv: OSVInputSpec!, $ghsa: GHSAInputSpec!, $isVulnerability: IsVulnerabilityInputSpec!) {\n  ingestIsVulnerability(\n    osv: $osv\n    vulnerability: {ghsa: $ghsa}\n    isVulnerability: $isVulnerability\n  ) {\n    ...AllIsVulnerability\n  }\n}"): (typeof documents)["mutation IsVulnerabilityCVE($osv: OSVInputSpec!, $cve: CVEInputSpec!, $isVulnerability: IsVulnerabilityInputSpec!) {\n  ingestIsVulnerability(\n    osv: $osv\n    vulnerability: {cve: $cve}\n    isVulnerability: $isVulnerability\n  ) {\n    ...AllIsVulnerability\n  }\n}\n\nmutation IsVulnerabilityGHSA($osv: OSVInputSpec!, $ghsa: GHSAInputSpec!, $isVulnerability: IsVulnerabilityInputSpec!) {\n  ingestIsVulnerability(\n    osv: $osv\n    vulnerability: {ghsa: $ghsa}\n    isVulnerability: $isVulnerability\n  ) {\n    ...AllIsVulnerability\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation HasMetadataPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}\n\nmutation HasMetadataSrc($source: SourceInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}\n\nmutation HasMetadataArtifact($artifact: ArtifactInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}"): (typeof documents)["mutation HasMetadataPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}\n\nmutation HasMetadataSrc($source: SourceInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}\n\nmutation HasMetadataArtifact($artifact: ArtifactInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  ) {\n    ...AllHasMetadata\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestOSV($osv: OSVInputSpec!) {\n  ingestOSV(osv: $osv) {\n    ...AllOSVTree\n  }\n}\n\nmutation IngestOSVs($osvs: [OSVInputSpec!]!) {\n  ingestOSVs(osvs: $osvs) {\n    ...AllOSVTree\n  }\n}\n\nquery OSVs($filter: OSVSpec!) {\n  osv(osvSpec: $filter) {\n    ...AllOSVTree\n  }\n}"): (typeof documents)["mutation IngestOSV($osv: OSVInputSpec!) {\n  ingestOSV(osv: $osv) {\n    ...AllOSVTree\n  }\n}\n\nmutation IngestOSVs($osvs: [OSVInputSpec!]!) {\n  ingestOSVs(osvs: $osvs) {\n    ...AllOSVTree\n  }\n}\n\nquery OSVs($filter: OSVSpec!) {\n  osv(osvSpec: $filter) {\n    ...AllOSVTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestPackage($pkg: PkgInputSpec!) {\n  ingestPackage(pkg: $pkg) {\n    ...AllPkgTree\n  }\n}\n\nmutation IngestPackages($pkgs: [PkgInputSpec!]!) {\n  ingestPackages(pkgs: $pkgs) {\n    ...AllPkgTree\n  }\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n      names {\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n      names {\n        name\n        versions {\n          version\n          qualifiers {\n            key\n            value\n          }\n        }\n      }\n    }\n  }\n}"): (typeof documents)["mutation IngestPackage($pkg: PkgInputSpec!) {\n  ingestPackage(pkg: $pkg) {\n    ...AllPkgTree\n  }\n}\n\nmutation IngestPackages($pkgs: [PkgInputSpec!]!) {\n  ingestPackages(pkgs: $pkgs) {\n    ...AllPkgTree\n  }\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n      names {\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    type\n    namespaces {\n      namespace\n      names {\n        name\n        versions {\n          version\n          qualifiers {\n            key\n            value\n          }\n        }\n      }\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}"): (typeof documents)["query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on IsVulnerability {\n      ...AllIsVulnerability\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation PkgEqual($pkg: PkgInputSpec!, $otherPackage: PkgInputSpec!, $pkgEqual: PkgEqualInputSpec!) {\n  pkg: ingestPackage(pkg: $pkg) {\n    ...AllPkgTree\n  }\n  otherPackage: ingestPackage(pkg: $otherPackage) {\n    ...AllPkgTree\n  }\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual) {\n    ...AllPkgEqual\n  }\n}"): (typeof documents)["mutation PkgEqual($pkg: PkgInputSpec!, $otherPackage: PkgInputSpec!, $pkgEqual: PkgEqualInputSpec!) {\n  pkg: ingestPackage(pkg: $pkg) {\n    ...AllPkgTree\n  }\n  otherPackage: ingestPackage(pkg: $otherPackage) {\n    ...AllPkgTree\n  }\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual) {\n    ...AllPkgEqual\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}"): (typeof documents)["query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestSource($source: SourceInputSpec!) {\n  ingestSource(source: $source) {\n    ...AllSourceTree\n  }\n}\n\nmutation IngestSources($sources: [SourceInputSpec!]!) {\n  ingestSources(sources: $sources) {\n    ...AllSourceTree\n  }\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}"): (typeof documents)["mutation IngestSource($source: SourceInputSpec!) {\n  ingestSource(source: $source) {\n    ...AllSourceTree\n  }\n}\n\nmutation IngestSources($sources: [SourceInputSpec!]!) {\n  ingestSources(sources: $sources) {\n    ...AllSourceTree\n  }\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllCveTree on CVE {\n  id\n  year\n  cveId\n}\n\nfragment AllGHSATree on GHSA {\n  id\n  ghsaId\n}\n\nfragment AllOSVTree on OSV {\n  id\n  osvId\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependentPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  versionRange\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllIsVulnerability on IsVulnerability {\n  id\n  osv {\n    ...AllOSVTree\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}"): (typeof documents)["fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllCveTree on CVE {\n  id\n  year\n  cveId\n}\n\nfragment AllGHSATree on GHSA {\n  id\n  ghsaId\n}\n\nfragment AllOSVTree on OSV {\n  id\n  osvId\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependentPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  versionRange\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on NoVuln {\n      id\n    }\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllIsVulnerability on IsVulnerability {\n  id\n  osv {\n    ...AllOSVTree\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    __typename\n    ... on CVE {\n      ...AllCveTree\n    }\n    ... on GHSA {\n      ...AllGHSATree\n    }\n    ... on OSV {\n      ...AllOSVTree\n    }\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}"];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;