/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
    "mutation IngestArtifact($artifact: IDorArtifactInput!) {\n  ingestArtifact(artifact: $artifact)\n}\n\nmutation IngestArtifacts($artifacts: [IDorArtifactInput!]!) {\n  ingestArtifacts(artifacts: $artifacts)\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}\n\nquery ArtifactsList($filter: ArtifactSpec!, $after: ID, $first: Int) {\n  artifactsList(artifactSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllArtifactTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestArtifactDocument,
    "mutation IngestBuilder($builder: IDorBuilderInput!) {\n  ingestBuilder(builder: $builder)\n}\n\nmutation IngestBuilders($builders: [IDorBuilderInput!]!) {\n  ingestBuilders(builders: $builders)\n}\n\nquery Builders($filter: BuilderSpec!) {\n  builders(builderSpec: $filter) {\n    ...AllBuilderTree\n  }\n}\n\nquery BuildersList($filter: BuilderSpec!, $after: ID, $first: Int) {\n  buildersList(builderSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllBuilderTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestBuilderDocument,
    "mutation IngestCertifyBadPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadSrc($source: IDorSourceInput!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadArtifact($artifact: IDorArtifactInput!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  )\n}\n\nmutation IngestCertifyBadSrcs($sources: [IDorSourceInput!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nmutation IngestCertifyBadArtifacts($artifacts: [IDorArtifactInput!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nquery CertifyBad($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}\n\nquery CertifyBadList($filter: CertifyBadSpec!, $after: ID, $first: Int) {\n  CertifyBadList(certifyBadSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyBad\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestCertifyBadPkgDocument,
    "mutation IngestCertifyGoodPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodSrc($source: IDorSourceInput!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodArtifact($artifact: IDorArtifactInput!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation IngestCertifyGoodSrcs($sources: [IDorSourceInput!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation IngestCertifyGoodArtifacts($artifacts: [IDorArtifactInput!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nquery CertifyGood($filter: CertifyGoodSpec!) {\n  CertifyGood(certifyGoodSpec: $filter) {\n    ...AllCertifyGood\n  }\n}\n\nquery CertifyGoodList($filter: CertifyGoodSpec!, $after: ID, $first: Int) {\n  CertifyGoodList(certifyGoodSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyGood\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestCertifyGoodPkgDocument,
    "mutation IngestCertifyLegalPkg($pkg: IDorPkgInput!, $declaredLicenses: [IDorLicenseInput!]!, $discoveredLicenses: [IDorLicenseInput!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {package: $pkg}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation IngestCertifyLegalPkgs($pkgs: [IDorPkgInput!]!, $declaredLicensesList: [[IDorLicenseInput!]!]!, $discoveredLicensesList: [[IDorLicenseInput!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {packages: $pkgs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nmutation IngestCertifyLegalSrc($src: IDorSourceInput!, $declaredLicenses: [IDorLicenseInput!]!, $discoveredLicenses: [IDorLicenseInput!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {source: $src}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation IngestCertifyLegalSrcs($srcs: [IDorSourceInput!]!, $declaredLicensesList: [[IDorLicenseInput!]!]!, $discoveredLicensesList: [[IDorLicenseInput!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {sources: $srcs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nquery CertifyLegal($filter: CertifyLegalSpec!) {\n  CertifyLegal(certifyLegalSpec: $filter) {\n    ...AllCertifyLegalTree\n  }\n}\n\nquery CertifyLegalList($filter: CertifyLegalSpec!, $after: ID, $first: Int) {\n  CertifyLegalList(certifyLegalSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyLegalTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestCertifyLegalPkgDocument,
    "mutation IngestCertifyScorecard($source: IDorSourceInput!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard)\n}\n\nmutation IngestCertifyScorecards($sources: [IDorSourceInput!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards)\n}\n\nquery Scorecards($filter: CertifyScorecardSpec!) {\n  scorecards(scorecardSpec: $filter) {\n    ...AllCertifyScorecard\n  }\n}\n\nquery ScorecardsList($filter: CertifyScorecardSpec!, $after: ID, $first: Int) {\n  scorecardsList(scorecardSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyScorecard\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestCertifyScorecardDocument,
    "mutation IngestCertifyVexPkg($pkg: IDorPkgInput!, $vulnerability: IDorVulnerabilityInput!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation IngestCertifyVexArtifact($artifact: IDorArtifactInput!, $vulnerability: IDorVulnerabilityInput!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation IngestCertifyVexPkgs($pkgs: [IDorPkgInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {packages: $pkgs}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nmutation IngestCertifyVexArtifacts($artifacts: [IDorArtifactInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {artifacts: $artifacts}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nquery VEXStatements($filter: CertifyVEXStatementSpec!) {\n  CertifyVEXStatement(certifyVEXStatementSpec: $filter) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nquery VEXStatementList($filter: CertifyVEXStatementSpec!, $after: ID, $first: Int) {\n  CertifyVEXStatementList(\n    certifyVEXStatementSpec: $filter\n    after: $after\n    first: $first\n  ) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyVEXStatement\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestCertifyVexPkgDocument,
    "mutation IngestCertifyVulnPkg($pkg: IDorPkgInput!, $vulnerability: IDorVulnerabilityInput!, $certifyVuln: ScanMetadataInput!) {\n  ingestCertifyVuln(\n    pkg: $pkg\n    vulnerability: $vulnerability\n    certifyVuln: $certifyVuln\n  )\n}\n\nmutation IngestCertifyVulnPkgs($pkgs: [IDorPkgInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $certifyVulns: [ScanMetadataInput!]!) {\n  ingestCertifyVulns(\n    pkgs: $pkgs\n    vulnerabilities: $vulnerabilities\n    certifyVulns: $certifyVulns\n  )\n}\n\nquery CertifyVuln($filter: CertifyVulnSpec!) {\n  CertifyVuln(certifyVulnSpec: $filter) {\n    ...AllCertifyVuln\n  }\n}\n\nquery CertifyVulnList($filter: CertifyVulnSpec!, $after: ID, $first: Int) {\n  CertifyVulnList(certifyVulnSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyVuln\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestCertifyVulnPkgDocument,
    "mutation IngestPointOfContactPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactSrc($source: IDorSourceInput!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactArtifact($artifact: IDorArtifactInput!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation IngestPointOfContactSrcs($sources: [IDorSourceInput!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation IngestPointOfContactArtifacts($artifacts: [IDorArtifactInput!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nquery PointOfContacts($filter: PointOfContactSpec!) {\n  PointOfContact(pointOfContactSpec: $filter) {\n    ...AllPointOfContact\n  }\n}\n\nquery PointOfContactList($filter: PointOfContactSpec!, $after: ID, $first: Int) {\n  PointOfContactList(pointOfContactSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPointOfContact\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestPointOfContactPkgDocument,
    "mutation Delete($nodeID: ID!) {\n  delete(node: $nodeID)\n}": types.DeleteDocument,
    "mutation IngestHasSBOMPkg($pkg: IDorPkgInput!, $hasSBOM: HasSBOMInputSpec!, $includes: HasSBOMIncludesInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM, includes: $includes)\n}\n\nmutation IngestHasSBOMArtifact($artifact: IDorArtifactInput!, $hasSBOM: HasSBOMInputSpec!, $includes: HasSBOMIncludesInputSpec!) {\n  ingestHasSBOM(\n    subject: {artifact: $artifact}\n    hasSBOM: $hasSBOM\n    includes: $includes\n  )\n}\n\nmutation IngestHasSBOMPkgs($pkgs: [IDorPkgInput!]!, $hasSBOMs: [HasSBOMInputSpec!]!, $includes: [HasSBOMIncludesInputSpec!]!) {\n  ingestHasSBOMs(\n    subjects: {packages: $pkgs}\n    hasSBOMs: $hasSBOMs\n    includes: $includes\n  )\n}\n\nmutation IngestHasSBOMArtifacts($artifacts: [IDorArtifactInput!]!, $hasSBOMs: [HasSBOMInputSpec!]!, $includes: [HasSBOMIncludesInputSpec!]!) {\n  ingestHasSBOMs(\n    subjects: {artifacts: $artifacts}\n    hasSBOMs: $hasSBOMs\n    includes: $includes\n  )\n}\n\nquery HasSBOMs($filter: HasSBOMSpec!) {\n  HasSBOM(hasSBOMSpec: $filter) {\n    ...AllHasSBOMTree\n  }\n}\n\nquery HasSBOMList($filter: HasSBOMSpec!, $after: ID, $first: Int) {\n  HasSBOMList(hasSBOMSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSBOMTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestHasSbomPkgDocument,
    "mutation IngestSLSAForArtifact($artifact: IDorArtifactInput!, $materials: [IDorArtifactInput!]!, $builder: IDorBuilderInput!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  )\n}\n\nmutation IngestSLSAForArtifacts($artifacts: [IDorArtifactInput!]!, $materialsList: [[IDorArtifactInput!]!]!, $builders: [IDorBuilderInput!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  )\n}\n\nquery HasSLSA($filter: HasSLSASpec!) {\n  HasSLSA(hasSLSASpec: $filter) {\n    ...AllHasSLSATree\n  }\n}\n\nquery HasSLSAList($filter: HasSLSASpec!, $after: ID, $first: Int) {\n  HasSLSAList(hasSLSASpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSLSATree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestSlsaForArtifactDocument,
    "mutation IngestHasSourceAt($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $source: IDorSourceInput!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  )\n}\n\nmutation IngestHasSourcesAt($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $sources: [IDorSourceInput!]!, $hasSourceAts: [HasSourceAtInputSpec!]!) {\n  ingestHasSourceAts(\n    pkgs: $pkgs\n    pkgMatchType: $pkgMatchType\n    sources: $sources\n    hasSourceAts: $hasSourceAts\n  )\n}\n\nquery HasSourceAt($filter: HasSourceAtSpec!) {\n  HasSourceAt(hasSourceAtSpec: $filter) {\n    ...AllHasSourceAt\n  }\n}\n\nquery HasSourceAtList($filter: HasSourceAtSpec!, $after: ID, $first: Int) {\n  HasSourceAtList(hasSourceAtSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSourceAt\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestHasSourceAtDocument,
    "mutation IngestHashEqual($artifact: IDorArtifactInput!, $otherArtifact: IDorArtifactInput!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  )\n}\n\nmutation IngestHashEquals($artifacts: [IDorArtifactInput!]!, $otherArtifacts: [IDorArtifactInput!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  )\n}\n\nquery HashEquals($filter: HashEqualSpec!) {\n  HashEqual(hashEqualSpec: $filter) {\n    ...AllHashEqualTree\n  }\n}\n\nquery HashEqualList($filter: HashEqualSpec!, $after: ID, $first: Int) {\n  HashEqualList(hashEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHashEqualTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestHashEqualDocument,
    "mutation IngestIsDependency($pkg: IDorPkgInput!, $depPkg: IDorPkgInput!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency)\n}\n\nmutation IngestIsDependencies($pkgs: [IDorPkgInput!]!, $depPkgs: [IDorPkgInput!]!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(pkgs: $pkgs, depPkgs: $depPkgs, dependencies: $dependencies)\n}\n\nquery Dependencies($filter: IsDependencySpec!) {\n  IsDependency(isDependencySpec: $filter) {\n    ...AllIsDependencyTree\n  }\n}\n\nquery DependencyList($filter: IsDependencySpec!, $after: ID, $first: Int) {\n  IsDependencyList(isDependencySpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllIsDependencyTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestIsDependencyDocument,
    "mutation IngestIsOccurrencePkg($pkg: IDorPkgInput!, $artifact: IDorArtifactInput!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IngestIsOccurrenceSrc($source: IDorSourceInput!, $artifact: IDorArtifactInput!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IngestIsOccurrencesPkg($pkgs: [IDorPkgInput!]!, $artifacts: [IDorArtifactInput!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nmutation IngestIsOccurrencesSrc($sources: [IDorSourceInput!]!, $artifacts: [IDorArtifactInput!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nquery Occurrences($filter: IsOccurrenceSpec!) {\n  IsOccurrence(isOccurrenceSpec: $filter) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nquery OccurrenceList($filter: IsOccurrenceSpec!, $after: ID, $first: Int) {\n  IsOccurrenceList(isOccurrenceSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllIsOccurrencesTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestIsOccurrencePkgDocument,
    "mutation IngestLicense($license: IDorLicenseInput!) {\n  ingestLicense(license: $license)\n}\n\nmutation IngestLicenses($licenses: [IDorLicenseInput!]!) {\n  ingestLicenses(licenses: $licenses)\n}\n\nquery Licenses($filter: LicenseSpec!) {\n  licenses(licenseSpec: $filter) {\n    ...AllLicenseTree\n  }\n}\n\nquery LicenseList($filter: LicenseSpec!, $after: ID, $first: Int) {\n  licenseList(licenseSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllLicenseTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestLicenseDocument,
    "mutation IngestHasMetadataPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataSrc($source: IDorSourceInput!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataArtifact($artifact: IDorArtifactInput!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation IngestHasMetadataSrcs($sources: [IDorSourceInput!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation IngestHasMetadataArtifacts($artifacts: [IDorArtifactInput!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nquery HasMetadata($filter: HasMetadataSpec!) {\n  HasMetadata(hasMetadataSpec: $filter) {\n    ...AllHasMetadata\n  }\n}\n\nquery HasMetadataList($filter: HasMetadataSpec!, $after: ID, $first: Int) {\n  HasMetadataList(hasMetadataSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasMetadata\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestHasMetadataPkgDocument,
    "mutation IngestPackage($pkg: IDorPkgInput!) {\n  ingestPackage(pkg: $pkg) {\n    packageTypeID\n    packageNamespaceID\n    packageNameID\n    packageVersionID\n  }\n}\n\nmutation IngestPackages($pkgs: [IDorPkgInput!]!) {\n  ingestPackages(pkgs: $pkgs) {\n    packageTypeID\n    packageNamespaceID\n    packageNameID\n    packageVersionID\n  }\n}\n\nquery PackagesList($filter: PkgSpec!, $after: ID, $first: Int) {\n  packagesList(pkgSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPkgTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n        versions {\n          id\n          version\n          qualifiers {\n            key\n            value\n          }\n          subpath\n        }\n      }\n    }\n  }\n}": types.IngestPackageDocument,
    "query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}": types.PathDocument,
    "mutation IngestPkgEqual($pkg: IDorPkgInput!, $otherPackage: IDorPkgInput!, $pkgEqual: PkgEqualInputSpec!) {\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual)\n}\n\nmutation IngestPkgEquals($pkgs: [IDorPkgInput!]!, $otherPackages: [IDorPkgInput!]!, $pkgEquals: [PkgEqualInputSpec!]!) {\n  ingestPkgEquals(\n    pkgs: $pkgs\n    otherPackages: $otherPackages\n    pkgEquals: $pkgEquals\n  )\n}\n\nquery PkgEquals($filter: PkgEqualSpec!) {\n  PkgEqual(pkgEqualSpec: $filter) {\n    ...AllPkgEqual\n  }\n}\n\nquery PkgEqualList($filter: PkgEqualSpec!, $after: ID, $first: Int) {\n  PkgEqualList(pkgEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPkgEqual\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestPkgEqualDocument,
    "query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}": types.FindSoftwareDocument,
    "mutation IngestSource($source: IDorSourceInput!) {\n  ingestSource(source: $source) {\n    sourceTypeID\n    sourceNamespaceID\n    sourceNameID\n  }\n}\n\nmutation IngestSources($sources: [IDorSourceInput!]!) {\n  ingestSources(sources: $sources) {\n    sourceTypeID\n    sourceNamespaceID\n    sourceNameID\n  }\n}\n\nquery SourcesList($filter: SourceSpec!, $after: ID, $first: Int) {\n  sourcesList(sourceSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllSourceTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}": types.IngestSourceDocument,
    "fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        purl\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllLicenseTree on License {\n  id\n  name\n  inline\n  listVersion\n}\n\nfragment AllVulnerabilityTree on Vulnerability {\n  id\n  type\n  vulnerabilityIDs {\n    id\n    vulnerabilityID\n  }\n}\n\nfragment AllVulnMetadataTree on VulnerabilityMetadata {\n  id\n  vulnerability {\n    id\n    type\n    vulnerabilityIDs {\n      id\n      vulnerabilityID\n    }\n  }\n  scoreType\n  scoreValue\n  timestamp\n  origin\n  collector\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependencyPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyLegalTree on CertifyLegal {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  declaredLicense\n  declaredLicenses {\n    ...AllLicenseTree\n  }\n  discoveredLicense\n  discoveredLicenses {\n    ...AllLicenseTree\n  }\n  attribution\n  justification\n  timeScanned\n  origin\n  collector\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n  knownSince\n  documentRef\n  includedSoftware {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  includedDependencies {\n    ...AllIsDependencyTree\n  }\n  includedOccurrences {\n    ...AllIsOccurrencesTree\n  }\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllVulnEqual on VulnEqual {\n  id\n  vulnerabilities {\n    ...AllVulnerabilityTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}\n\nfragment AllHasSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      ...AllBuilderTree\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n    documentRef\n  }\n}": types.AllPkgTreeFragmentDoc,
    "mutation IngestVulnEqual($vulnerability: IDorVulnerabilityInput!, $otherVulnerability: IDorVulnerabilityInput!, $vulnEqual: VulnEqualInputSpec!) {\n  ingestVulnEqual(\n    vulnerability: $vulnerability\n    otherVulnerability: $otherVulnerability\n    vulnEqual: $vulnEqual\n  )\n}\n\nmutation IngestVulnEquals($vulnerabilities: [IDorVulnerabilityInput!]!, $otherVulnerabilities: [IDorVulnerabilityInput!]!, $vulnEquals: [VulnEqualInputSpec!]!) {\n  ingestVulnEquals(\n    vulnerabilities: $vulnerabilities\n    otherVulnerabilities: $otherVulnerabilities\n    vulnEquals: $vulnEquals\n  )\n}\n\nquery VulnEquals($filter: VulnEqualSpec!) {\n  vulnEqual(vulnEqualSpec: $filter) {\n    ...AllVulnEqual\n  }\n}\n\nquery VulnEqualList($filter: VulnEqualSpec!, $after: ID, $first: Int) {\n  vulnEqualList(vulnEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnEqual\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestVulnEqualDocument,
    "mutation IngestVulnHasMetadata($vulnerability: IDorVulnerabilityInput!, $vulnMetadata: VulnerabilityMetadataInputSpec!) {\n  ingestVulnerabilityMetadata(\n    vulnerability: $vulnerability\n    vulnerabilityMetadata: $vulnMetadata\n  )\n}\n\nmutation IngestBulkVulnHasMetadata($vulnerabilities: [IDorVulnerabilityInput!]!, $vulnerabilityMetadataList: [VulnerabilityMetadataInputSpec!]!) {\n  ingestBulkVulnerabilityMetadata(\n    vulnerabilities: $vulnerabilities\n    vulnerabilityMetadataList: $vulnerabilityMetadataList\n  )\n}\n\nquery VulnerabilityMetadata($filter: VulnerabilityMetadataSpec!) {\n  vulnerabilityMetadata(vulnerabilityMetadataSpec: $filter) {\n    ...AllVulnMetadataTree\n  }\n}\n\nquery VulnerabilityMetadataList($filter: VulnerabilityMetadataSpec!, $after: ID, $first: Int) {\n  vulnerabilityMetadataList(\n    vulnerabilityMetadataSpec: $filter\n    after: $after\n    first: $first\n  ) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnMetadataTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestVulnHasMetadataDocument,
    "mutation IngestVulnerability($vuln: IDorVulnerabilityInput!) {\n  ingestVulnerability(vuln: $vuln) {\n    vulnerabilityTypeID\n    vulnerabilityNodeID\n  }\n}\n\nmutation IngestVulnerabilities($vulns: [IDorVulnerabilityInput!]!) {\n  ingestVulnerabilities(vulns: $vulns) {\n    vulnerabilityTypeID\n    vulnerabilityNodeID\n  }\n}\n\nquery Vulnerabilities($filter: VulnerabilitySpec!) {\n  vulnerabilities(vulnSpec: $filter) {\n    ...AllVulnerabilityTree\n  }\n}\n\nquery VulnerabilityList($filter: VulnerabilitySpec!, $after: ID, $first: Int) {\n  vulnerabilityList(vulnSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnerabilityTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}": types.IngestVulnerabilityDocument,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestArtifact($artifact: IDorArtifactInput!) {\n  ingestArtifact(artifact: $artifact)\n}\n\nmutation IngestArtifacts($artifacts: [IDorArtifactInput!]!) {\n  ingestArtifacts(artifacts: $artifacts)\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}\n\nquery ArtifactsList($filter: ArtifactSpec!, $after: ID, $first: Int) {\n  artifactsList(artifactSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllArtifactTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestArtifact($artifact: IDorArtifactInput!) {\n  ingestArtifact(artifact: $artifact)\n}\n\nmutation IngestArtifacts($artifacts: [IDorArtifactInput!]!) {\n  ingestArtifacts(artifacts: $artifacts)\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}\n\nquery ArtifactsList($filter: ArtifactSpec!, $after: ID, $first: Int) {\n  artifactsList(artifactSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllArtifactTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestBuilder($builder: IDorBuilderInput!) {\n  ingestBuilder(builder: $builder)\n}\n\nmutation IngestBuilders($builders: [IDorBuilderInput!]!) {\n  ingestBuilders(builders: $builders)\n}\n\nquery Builders($filter: BuilderSpec!) {\n  builders(builderSpec: $filter) {\n    ...AllBuilderTree\n  }\n}\n\nquery BuildersList($filter: BuilderSpec!, $after: ID, $first: Int) {\n  buildersList(builderSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllBuilderTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestBuilder($builder: IDorBuilderInput!) {\n  ingestBuilder(builder: $builder)\n}\n\nmutation IngestBuilders($builders: [IDorBuilderInput!]!) {\n  ingestBuilders(builders: $builders)\n}\n\nquery Builders($filter: BuilderSpec!) {\n  builders(builderSpec: $filter) {\n    ...AllBuilderTree\n  }\n}\n\nquery BuildersList($filter: BuilderSpec!, $after: ID, $first: Int) {\n  buildersList(builderSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllBuilderTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestCertifyBadPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadSrc($source: IDorSourceInput!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadArtifact($artifact: IDorArtifactInput!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  )\n}\n\nmutation IngestCertifyBadSrcs($sources: [IDorSourceInput!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nmutation IngestCertifyBadArtifacts($artifacts: [IDorArtifactInput!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nquery CertifyBad($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}\n\nquery CertifyBadList($filter: CertifyBadSpec!, $after: ID, $first: Int) {\n  CertifyBadList(certifyBadSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyBad\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestCertifyBadPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadSrc($source: IDorSourceInput!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadArtifact($artifact: IDorArtifactInput!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation IngestCertifyBadPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  )\n}\n\nmutation IngestCertifyBadSrcs($sources: [IDorSourceInput!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nmutation IngestCertifyBadArtifacts($artifacts: [IDorArtifactInput!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nquery CertifyBad($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}\n\nquery CertifyBadList($filter: CertifyBadSpec!, $after: ID, $first: Int) {\n  CertifyBadList(certifyBadSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyBad\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestCertifyGoodPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodSrc($source: IDorSourceInput!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodArtifact($artifact: IDorArtifactInput!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation IngestCertifyGoodSrcs($sources: [IDorSourceInput!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation IngestCertifyGoodArtifacts($artifacts: [IDorArtifactInput!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nquery CertifyGood($filter: CertifyGoodSpec!) {\n  CertifyGood(certifyGoodSpec: $filter) {\n    ...AllCertifyGood\n  }\n}\n\nquery CertifyGoodList($filter: CertifyGoodSpec!, $after: ID, $first: Int) {\n  CertifyGoodList(certifyGoodSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyGood\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestCertifyGoodPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodSrc($source: IDorSourceInput!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodArtifact($artifact: IDorArtifactInput!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation IngestCertifyGoodPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation IngestCertifyGoodSrcs($sources: [IDorSourceInput!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation IngestCertifyGoodArtifacts($artifacts: [IDorArtifactInput!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nquery CertifyGood($filter: CertifyGoodSpec!) {\n  CertifyGood(certifyGoodSpec: $filter) {\n    ...AllCertifyGood\n  }\n}\n\nquery CertifyGoodList($filter: CertifyGoodSpec!, $after: ID, $first: Int) {\n  CertifyGoodList(certifyGoodSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyGood\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestCertifyLegalPkg($pkg: IDorPkgInput!, $declaredLicenses: [IDorLicenseInput!]!, $discoveredLicenses: [IDorLicenseInput!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {package: $pkg}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation IngestCertifyLegalPkgs($pkgs: [IDorPkgInput!]!, $declaredLicensesList: [[IDorLicenseInput!]!]!, $discoveredLicensesList: [[IDorLicenseInput!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {packages: $pkgs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nmutation IngestCertifyLegalSrc($src: IDorSourceInput!, $declaredLicenses: [IDorLicenseInput!]!, $discoveredLicenses: [IDorLicenseInput!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {source: $src}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation IngestCertifyLegalSrcs($srcs: [IDorSourceInput!]!, $declaredLicensesList: [[IDorLicenseInput!]!]!, $discoveredLicensesList: [[IDorLicenseInput!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {sources: $srcs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nquery CertifyLegal($filter: CertifyLegalSpec!) {\n  CertifyLegal(certifyLegalSpec: $filter) {\n    ...AllCertifyLegalTree\n  }\n}\n\nquery CertifyLegalList($filter: CertifyLegalSpec!, $after: ID, $first: Int) {\n  CertifyLegalList(certifyLegalSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyLegalTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestCertifyLegalPkg($pkg: IDorPkgInput!, $declaredLicenses: [IDorLicenseInput!]!, $discoveredLicenses: [IDorLicenseInput!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {package: $pkg}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation IngestCertifyLegalPkgs($pkgs: [IDorPkgInput!]!, $declaredLicensesList: [[IDorLicenseInput!]!]!, $discoveredLicensesList: [[IDorLicenseInput!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {packages: $pkgs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nmutation IngestCertifyLegalSrc($src: IDorSourceInput!, $declaredLicenses: [IDorLicenseInput!]!, $discoveredLicenses: [IDorLicenseInput!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {source: $src}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation IngestCertifyLegalSrcs($srcs: [IDorSourceInput!]!, $declaredLicensesList: [[IDorLicenseInput!]!]!, $discoveredLicensesList: [[IDorLicenseInput!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {sources: $srcs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nquery CertifyLegal($filter: CertifyLegalSpec!) {\n  CertifyLegal(certifyLegalSpec: $filter) {\n    ...AllCertifyLegalTree\n  }\n}\n\nquery CertifyLegalList($filter: CertifyLegalSpec!, $after: ID, $first: Int) {\n  CertifyLegalList(certifyLegalSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyLegalTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestCertifyScorecard($source: IDorSourceInput!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard)\n}\n\nmutation IngestCertifyScorecards($sources: [IDorSourceInput!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards)\n}\n\nquery Scorecards($filter: CertifyScorecardSpec!) {\n  scorecards(scorecardSpec: $filter) {\n    ...AllCertifyScorecard\n  }\n}\n\nquery ScorecardsList($filter: CertifyScorecardSpec!, $after: ID, $first: Int) {\n  scorecardsList(scorecardSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyScorecard\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestCertifyScorecard($source: IDorSourceInput!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard)\n}\n\nmutation IngestCertifyScorecards($sources: [IDorSourceInput!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards)\n}\n\nquery Scorecards($filter: CertifyScorecardSpec!) {\n  scorecards(scorecardSpec: $filter) {\n    ...AllCertifyScorecard\n  }\n}\n\nquery ScorecardsList($filter: CertifyScorecardSpec!, $after: ID, $first: Int) {\n  scorecardsList(scorecardSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyScorecard\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestCertifyVexPkg($pkg: IDorPkgInput!, $vulnerability: IDorVulnerabilityInput!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation IngestCertifyVexArtifact($artifact: IDorArtifactInput!, $vulnerability: IDorVulnerabilityInput!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation IngestCertifyVexPkgs($pkgs: [IDorPkgInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {packages: $pkgs}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nmutation IngestCertifyVexArtifacts($artifacts: [IDorArtifactInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {artifacts: $artifacts}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nquery VEXStatements($filter: CertifyVEXStatementSpec!) {\n  CertifyVEXStatement(certifyVEXStatementSpec: $filter) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nquery VEXStatementList($filter: CertifyVEXStatementSpec!, $after: ID, $first: Int) {\n  CertifyVEXStatementList(\n    certifyVEXStatementSpec: $filter\n    after: $after\n    first: $first\n  ) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyVEXStatement\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestCertifyVexPkg($pkg: IDorPkgInput!, $vulnerability: IDorVulnerabilityInput!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation IngestCertifyVexArtifact($artifact: IDorArtifactInput!, $vulnerability: IDorVulnerabilityInput!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation IngestCertifyVexPkgs($pkgs: [IDorPkgInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {packages: $pkgs}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nmutation IngestCertifyVexArtifacts($artifacts: [IDorArtifactInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {artifacts: $artifacts}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nquery VEXStatements($filter: CertifyVEXStatementSpec!) {\n  CertifyVEXStatement(certifyVEXStatementSpec: $filter) {\n    ...AllCertifyVEXStatement\n  }\n}\n\nquery VEXStatementList($filter: CertifyVEXStatementSpec!, $after: ID, $first: Int) {\n  CertifyVEXStatementList(\n    certifyVEXStatementSpec: $filter\n    after: $after\n    first: $first\n  ) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyVEXStatement\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestCertifyVulnPkg($pkg: IDorPkgInput!, $vulnerability: IDorVulnerabilityInput!, $certifyVuln: ScanMetadataInput!) {\n  ingestCertifyVuln(\n    pkg: $pkg\n    vulnerability: $vulnerability\n    certifyVuln: $certifyVuln\n  )\n}\n\nmutation IngestCertifyVulnPkgs($pkgs: [IDorPkgInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $certifyVulns: [ScanMetadataInput!]!) {\n  ingestCertifyVulns(\n    pkgs: $pkgs\n    vulnerabilities: $vulnerabilities\n    certifyVulns: $certifyVulns\n  )\n}\n\nquery CertifyVuln($filter: CertifyVulnSpec!) {\n  CertifyVuln(certifyVulnSpec: $filter) {\n    ...AllCertifyVuln\n  }\n}\n\nquery CertifyVulnList($filter: CertifyVulnSpec!, $after: ID, $first: Int) {\n  CertifyVulnList(certifyVulnSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyVuln\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestCertifyVulnPkg($pkg: IDorPkgInput!, $vulnerability: IDorVulnerabilityInput!, $certifyVuln: ScanMetadataInput!) {\n  ingestCertifyVuln(\n    pkg: $pkg\n    vulnerability: $vulnerability\n    certifyVuln: $certifyVuln\n  )\n}\n\nmutation IngestCertifyVulnPkgs($pkgs: [IDorPkgInput!]!, $vulnerabilities: [IDorVulnerabilityInput!]!, $certifyVulns: [ScanMetadataInput!]!) {\n  ingestCertifyVulns(\n    pkgs: $pkgs\n    vulnerabilities: $vulnerabilities\n    certifyVulns: $certifyVulns\n  )\n}\n\nquery CertifyVuln($filter: CertifyVulnSpec!) {\n  CertifyVuln(certifyVulnSpec: $filter) {\n    ...AllCertifyVuln\n  }\n}\n\nquery CertifyVulnList($filter: CertifyVulnSpec!, $after: ID, $first: Int) {\n  CertifyVulnList(certifyVulnSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllCertifyVuln\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestPointOfContactPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactSrc($source: IDorSourceInput!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactArtifact($artifact: IDorArtifactInput!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation IngestPointOfContactSrcs($sources: [IDorSourceInput!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation IngestPointOfContactArtifacts($artifacts: [IDorArtifactInput!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nquery PointOfContacts($filter: PointOfContactSpec!) {\n  PointOfContact(pointOfContactSpec: $filter) {\n    ...AllPointOfContact\n  }\n}\n\nquery PointOfContactList($filter: PointOfContactSpec!, $after: ID, $first: Int) {\n  PointOfContactList(pointOfContactSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPointOfContact\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestPointOfContactPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactSrc($source: IDorSourceInput!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactArtifact($artifact: IDorArtifactInput!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation IngestPointOfContactPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation IngestPointOfContactSrcs($sources: [IDorSourceInput!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation IngestPointOfContactArtifacts($artifacts: [IDorArtifactInput!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nquery PointOfContacts($filter: PointOfContactSpec!) {\n  PointOfContact(pointOfContactSpec: $filter) {\n    ...AllPointOfContact\n  }\n}\n\nquery PointOfContactList($filter: PointOfContactSpec!, $after: ID, $first: Int) {\n  PointOfContactList(pointOfContactSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPointOfContact\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation Delete($nodeID: ID!) {\n  delete(node: $nodeID)\n}"): (typeof documents)["mutation Delete($nodeID: ID!) {\n  delete(node: $nodeID)\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestHasSBOMPkg($pkg: IDorPkgInput!, $hasSBOM: HasSBOMInputSpec!, $includes: HasSBOMIncludesInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM, includes: $includes)\n}\n\nmutation IngestHasSBOMArtifact($artifact: IDorArtifactInput!, $hasSBOM: HasSBOMInputSpec!, $includes: HasSBOMIncludesInputSpec!) {\n  ingestHasSBOM(\n    subject: {artifact: $artifact}\n    hasSBOM: $hasSBOM\n    includes: $includes\n  )\n}\n\nmutation IngestHasSBOMPkgs($pkgs: [IDorPkgInput!]!, $hasSBOMs: [HasSBOMInputSpec!]!, $includes: [HasSBOMIncludesInputSpec!]!) {\n  ingestHasSBOMs(\n    subjects: {packages: $pkgs}\n    hasSBOMs: $hasSBOMs\n    includes: $includes\n  )\n}\n\nmutation IngestHasSBOMArtifacts($artifacts: [IDorArtifactInput!]!, $hasSBOMs: [HasSBOMInputSpec!]!, $includes: [HasSBOMIncludesInputSpec!]!) {\n  ingestHasSBOMs(\n    subjects: {artifacts: $artifacts}\n    hasSBOMs: $hasSBOMs\n    includes: $includes\n  )\n}\n\nquery HasSBOMs($filter: HasSBOMSpec!) {\n  HasSBOM(hasSBOMSpec: $filter) {\n    ...AllHasSBOMTree\n  }\n}\n\nquery HasSBOMList($filter: HasSBOMSpec!, $after: ID, $first: Int) {\n  HasSBOMList(hasSBOMSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSBOMTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestHasSBOMPkg($pkg: IDorPkgInput!, $hasSBOM: HasSBOMInputSpec!, $includes: HasSBOMIncludesInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM, includes: $includes)\n}\n\nmutation IngestHasSBOMArtifact($artifact: IDorArtifactInput!, $hasSBOM: HasSBOMInputSpec!, $includes: HasSBOMIncludesInputSpec!) {\n  ingestHasSBOM(\n    subject: {artifact: $artifact}\n    hasSBOM: $hasSBOM\n    includes: $includes\n  )\n}\n\nmutation IngestHasSBOMPkgs($pkgs: [IDorPkgInput!]!, $hasSBOMs: [HasSBOMInputSpec!]!, $includes: [HasSBOMIncludesInputSpec!]!) {\n  ingestHasSBOMs(\n    subjects: {packages: $pkgs}\n    hasSBOMs: $hasSBOMs\n    includes: $includes\n  )\n}\n\nmutation IngestHasSBOMArtifacts($artifacts: [IDorArtifactInput!]!, $hasSBOMs: [HasSBOMInputSpec!]!, $includes: [HasSBOMIncludesInputSpec!]!) {\n  ingestHasSBOMs(\n    subjects: {artifacts: $artifacts}\n    hasSBOMs: $hasSBOMs\n    includes: $includes\n  )\n}\n\nquery HasSBOMs($filter: HasSBOMSpec!) {\n  HasSBOM(hasSBOMSpec: $filter) {\n    ...AllHasSBOMTree\n  }\n}\n\nquery HasSBOMList($filter: HasSBOMSpec!, $after: ID, $first: Int) {\n  HasSBOMList(hasSBOMSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSBOMTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestSLSAForArtifact($artifact: IDorArtifactInput!, $materials: [IDorArtifactInput!]!, $builder: IDorBuilderInput!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  )\n}\n\nmutation IngestSLSAForArtifacts($artifacts: [IDorArtifactInput!]!, $materialsList: [[IDorArtifactInput!]!]!, $builders: [IDorBuilderInput!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  )\n}\n\nquery HasSLSA($filter: HasSLSASpec!) {\n  HasSLSA(hasSLSASpec: $filter) {\n    ...AllHasSLSATree\n  }\n}\n\nquery HasSLSAList($filter: HasSLSASpec!, $after: ID, $first: Int) {\n  HasSLSAList(hasSLSASpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSLSATree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestSLSAForArtifact($artifact: IDorArtifactInput!, $materials: [IDorArtifactInput!]!, $builder: IDorBuilderInput!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  )\n}\n\nmutation IngestSLSAForArtifacts($artifacts: [IDorArtifactInput!]!, $materialsList: [[IDorArtifactInput!]!]!, $builders: [IDorBuilderInput!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  )\n}\n\nquery HasSLSA($filter: HasSLSASpec!) {\n  HasSLSA(hasSLSASpec: $filter) {\n    ...AllHasSLSATree\n  }\n}\n\nquery HasSLSAList($filter: HasSLSASpec!, $after: ID, $first: Int) {\n  HasSLSAList(hasSLSASpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSLSATree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestHasSourceAt($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $source: IDorSourceInput!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  )\n}\n\nmutation IngestHasSourcesAt($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $sources: [IDorSourceInput!]!, $hasSourceAts: [HasSourceAtInputSpec!]!) {\n  ingestHasSourceAts(\n    pkgs: $pkgs\n    pkgMatchType: $pkgMatchType\n    sources: $sources\n    hasSourceAts: $hasSourceAts\n  )\n}\n\nquery HasSourceAt($filter: HasSourceAtSpec!) {\n  HasSourceAt(hasSourceAtSpec: $filter) {\n    ...AllHasSourceAt\n  }\n}\n\nquery HasSourceAtList($filter: HasSourceAtSpec!, $after: ID, $first: Int) {\n  HasSourceAtList(hasSourceAtSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSourceAt\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestHasSourceAt($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $source: IDorSourceInput!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  )\n}\n\nmutation IngestHasSourcesAt($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $sources: [IDorSourceInput!]!, $hasSourceAts: [HasSourceAtInputSpec!]!) {\n  ingestHasSourceAts(\n    pkgs: $pkgs\n    pkgMatchType: $pkgMatchType\n    sources: $sources\n    hasSourceAts: $hasSourceAts\n  )\n}\n\nquery HasSourceAt($filter: HasSourceAtSpec!) {\n  HasSourceAt(hasSourceAtSpec: $filter) {\n    ...AllHasSourceAt\n  }\n}\n\nquery HasSourceAtList($filter: HasSourceAtSpec!, $after: ID, $first: Int) {\n  HasSourceAtList(hasSourceAtSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasSourceAt\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestHashEqual($artifact: IDorArtifactInput!, $otherArtifact: IDorArtifactInput!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  )\n}\n\nmutation IngestHashEquals($artifacts: [IDorArtifactInput!]!, $otherArtifacts: [IDorArtifactInput!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  )\n}\n\nquery HashEquals($filter: HashEqualSpec!) {\n  HashEqual(hashEqualSpec: $filter) {\n    ...AllHashEqualTree\n  }\n}\n\nquery HashEqualList($filter: HashEqualSpec!, $after: ID, $first: Int) {\n  HashEqualList(hashEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHashEqualTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestHashEqual($artifact: IDorArtifactInput!, $otherArtifact: IDorArtifactInput!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  )\n}\n\nmutation IngestHashEquals($artifacts: [IDorArtifactInput!]!, $otherArtifacts: [IDorArtifactInput!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  )\n}\n\nquery HashEquals($filter: HashEqualSpec!) {\n  HashEqual(hashEqualSpec: $filter) {\n    ...AllHashEqualTree\n  }\n}\n\nquery HashEqualList($filter: HashEqualSpec!, $after: ID, $first: Int) {\n  HashEqualList(hashEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHashEqualTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestIsDependency($pkg: IDorPkgInput!, $depPkg: IDorPkgInput!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency)\n}\n\nmutation IngestIsDependencies($pkgs: [IDorPkgInput!]!, $depPkgs: [IDorPkgInput!]!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(pkgs: $pkgs, depPkgs: $depPkgs, dependencies: $dependencies)\n}\n\nquery Dependencies($filter: IsDependencySpec!) {\n  IsDependency(isDependencySpec: $filter) {\n    ...AllIsDependencyTree\n  }\n}\n\nquery DependencyList($filter: IsDependencySpec!, $after: ID, $first: Int) {\n  IsDependencyList(isDependencySpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllIsDependencyTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestIsDependency($pkg: IDorPkgInput!, $depPkg: IDorPkgInput!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency)\n}\n\nmutation IngestIsDependencies($pkgs: [IDorPkgInput!]!, $depPkgs: [IDorPkgInput!]!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(pkgs: $pkgs, depPkgs: $depPkgs, dependencies: $dependencies)\n}\n\nquery Dependencies($filter: IsDependencySpec!) {\n  IsDependency(isDependencySpec: $filter) {\n    ...AllIsDependencyTree\n  }\n}\n\nquery DependencyList($filter: IsDependencySpec!, $after: ID, $first: Int) {\n  IsDependencyList(isDependencySpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllIsDependencyTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestIsOccurrencePkg($pkg: IDorPkgInput!, $artifact: IDorArtifactInput!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IngestIsOccurrenceSrc($source: IDorSourceInput!, $artifact: IDorArtifactInput!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IngestIsOccurrencesPkg($pkgs: [IDorPkgInput!]!, $artifacts: [IDorArtifactInput!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nmutation IngestIsOccurrencesSrc($sources: [IDorSourceInput!]!, $artifacts: [IDorArtifactInput!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nquery Occurrences($filter: IsOccurrenceSpec!) {\n  IsOccurrence(isOccurrenceSpec: $filter) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nquery OccurrenceList($filter: IsOccurrenceSpec!, $after: ID, $first: Int) {\n  IsOccurrenceList(isOccurrenceSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllIsOccurrencesTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestIsOccurrencePkg($pkg: IDorPkgInput!, $artifact: IDorArtifactInput!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IngestIsOccurrenceSrc($source: IDorSourceInput!, $artifact: IDorArtifactInput!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IngestIsOccurrencesPkg($pkgs: [IDorPkgInput!]!, $artifacts: [IDorArtifactInput!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nmutation IngestIsOccurrencesSrc($sources: [IDorSourceInput!]!, $artifacts: [IDorArtifactInput!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nquery Occurrences($filter: IsOccurrenceSpec!) {\n  IsOccurrence(isOccurrenceSpec: $filter) {\n    ...AllIsOccurrencesTree\n  }\n}\n\nquery OccurrenceList($filter: IsOccurrenceSpec!, $after: ID, $first: Int) {\n  IsOccurrenceList(isOccurrenceSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllIsOccurrencesTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestLicense($license: IDorLicenseInput!) {\n  ingestLicense(license: $license)\n}\n\nmutation IngestLicenses($licenses: [IDorLicenseInput!]!) {\n  ingestLicenses(licenses: $licenses)\n}\n\nquery Licenses($filter: LicenseSpec!) {\n  licenses(licenseSpec: $filter) {\n    ...AllLicenseTree\n  }\n}\n\nquery LicenseList($filter: LicenseSpec!, $after: ID, $first: Int) {\n  licenseList(licenseSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllLicenseTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestLicense($license: IDorLicenseInput!) {\n  ingestLicense(license: $license)\n}\n\nmutation IngestLicenses($licenses: [IDorLicenseInput!]!) {\n  ingestLicenses(licenses: $licenses)\n}\n\nquery Licenses($filter: LicenseSpec!) {\n  licenses(licenseSpec: $filter) {\n    ...AllLicenseTree\n  }\n}\n\nquery LicenseList($filter: LicenseSpec!, $after: ID, $first: Int) {\n  licenseList(licenseSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllLicenseTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestHasMetadataPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataSrc($source: IDorSourceInput!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataArtifact($artifact: IDorArtifactInput!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation IngestHasMetadataSrcs($sources: [IDorSourceInput!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation IngestHasMetadataArtifacts($artifacts: [IDorArtifactInput!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nquery HasMetadata($filter: HasMetadataSpec!) {\n  HasMetadata(hasMetadataSpec: $filter) {\n    ...AllHasMetadata\n  }\n}\n\nquery HasMetadataList($filter: HasMetadataSpec!, $after: ID, $first: Int) {\n  HasMetadataList(hasMetadataSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasMetadata\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestHasMetadataPkg($pkg: IDorPkgInput!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataSrc($source: IDorSourceInput!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataArtifact($artifact: IDorArtifactInput!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation IngestHasMetadataPkgs($pkgs: [IDorPkgInput!]!, $pkgMatchType: MatchFlags!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation IngestHasMetadataSrcs($sources: [IDorSourceInput!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation IngestHasMetadataArtifacts($artifacts: [IDorArtifactInput!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nquery HasMetadata($filter: HasMetadataSpec!) {\n  HasMetadata(hasMetadataSpec: $filter) {\n    ...AllHasMetadata\n  }\n}\n\nquery HasMetadataList($filter: HasMetadataSpec!, $after: ID, $first: Int) {\n  HasMetadataList(hasMetadataSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllHasMetadata\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestPackage($pkg: IDorPkgInput!) {\n  ingestPackage(pkg: $pkg) {\n    packageTypeID\n    packageNamespaceID\n    packageNameID\n    packageVersionID\n  }\n}\n\nmutation IngestPackages($pkgs: [IDorPkgInput!]!) {\n  ingestPackages(pkgs: $pkgs) {\n    packageTypeID\n    packageNamespaceID\n    packageNameID\n    packageVersionID\n  }\n}\n\nquery PackagesList($filter: PkgSpec!, $after: ID, $first: Int) {\n  packagesList(pkgSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPkgTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n        versions {\n          id\n          version\n          qualifiers {\n            key\n            value\n          }\n          subpath\n        }\n      }\n    }\n  }\n}"): (typeof documents)["mutation IngestPackage($pkg: IDorPkgInput!) {\n  ingestPackage(pkg: $pkg) {\n    packageTypeID\n    packageNamespaceID\n    packageNameID\n    packageVersionID\n  }\n}\n\nmutation IngestPackages($pkgs: [IDorPkgInput!]!) {\n  ingestPackages(pkgs: $pkgs) {\n    packageTypeID\n    packageNamespaceID\n    packageNameID\n    packageVersionID\n  }\n}\n\nquery PackagesList($filter: PkgSpec!, $after: ID, $first: Int) {\n  packagesList(pkgSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPkgTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n        versions {\n          id\n          version\n          qualifiers {\n            key\n            value\n          }\n          subpath\n        }\n      }\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}"): (typeof documents)["query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestPkgEqual($pkg: IDorPkgInput!, $otherPackage: IDorPkgInput!, $pkgEqual: PkgEqualInputSpec!) {\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual)\n}\n\nmutation IngestPkgEquals($pkgs: [IDorPkgInput!]!, $otherPackages: [IDorPkgInput!]!, $pkgEquals: [PkgEqualInputSpec!]!) {\n  ingestPkgEquals(\n    pkgs: $pkgs\n    otherPackages: $otherPackages\n    pkgEquals: $pkgEquals\n  )\n}\n\nquery PkgEquals($filter: PkgEqualSpec!) {\n  PkgEqual(pkgEqualSpec: $filter) {\n    ...AllPkgEqual\n  }\n}\n\nquery PkgEqualList($filter: PkgEqualSpec!, $after: ID, $first: Int) {\n  PkgEqualList(pkgEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPkgEqual\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestPkgEqual($pkg: IDorPkgInput!, $otherPackage: IDorPkgInput!, $pkgEqual: PkgEqualInputSpec!) {\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual)\n}\n\nmutation IngestPkgEquals($pkgs: [IDorPkgInput!]!, $otherPackages: [IDorPkgInput!]!, $pkgEquals: [PkgEqualInputSpec!]!) {\n  ingestPkgEquals(\n    pkgs: $pkgs\n    otherPackages: $otherPackages\n    pkgEquals: $pkgEquals\n  )\n}\n\nquery PkgEquals($filter: PkgEqualSpec!) {\n  PkgEqual(pkgEqualSpec: $filter) {\n    ...AllPkgEqual\n  }\n}\n\nquery PkgEqualList($filter: PkgEqualSpec!, $after: ID, $first: Int) {\n  PkgEqualList(pkgEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllPkgEqual\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}"): (typeof documents)["query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestSource($source: IDorSourceInput!) {\n  ingestSource(source: $source) {\n    sourceTypeID\n    sourceNamespaceID\n    sourceNameID\n  }\n}\n\nmutation IngestSources($sources: [IDorSourceInput!]!) {\n  ingestSources(sources: $sources) {\n    sourceTypeID\n    sourceNamespaceID\n    sourceNameID\n  }\n}\n\nquery SourcesList($filter: SourceSpec!, $after: ID, $first: Int) {\n  sourcesList(sourceSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllSourceTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}"): (typeof documents)["mutation IngestSource($source: IDorSourceInput!) {\n  ingestSource(source: $source) {\n    sourceTypeID\n    sourceNamespaceID\n    sourceNameID\n  }\n}\n\nmutation IngestSources($sources: [IDorSourceInput!]!) {\n  ingestSources(sources: $sources) {\n    sourceTypeID\n    sourceNamespaceID\n    sourceNameID\n  }\n}\n\nquery SourcesList($filter: SourceSpec!, $after: ID, $first: Int) {\n  sourcesList(sourceSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllSourceTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        purl\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllLicenseTree on License {\n  id\n  name\n  inline\n  listVersion\n}\n\nfragment AllVulnerabilityTree on Vulnerability {\n  id\n  type\n  vulnerabilityIDs {\n    id\n    vulnerabilityID\n  }\n}\n\nfragment AllVulnMetadataTree on VulnerabilityMetadata {\n  id\n  vulnerability {\n    id\n    type\n    vulnerabilityIDs {\n      id\n      vulnerabilityID\n    }\n  }\n  scoreType\n  scoreValue\n  timestamp\n  origin\n  collector\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependencyPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyLegalTree on CertifyLegal {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  declaredLicense\n  declaredLicenses {\n    ...AllLicenseTree\n  }\n  discoveredLicense\n  discoveredLicenses {\n    ...AllLicenseTree\n  }\n  attribution\n  justification\n  timeScanned\n  origin\n  collector\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n  knownSince\n  documentRef\n  includedSoftware {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  includedDependencies {\n    ...AllIsDependencyTree\n  }\n  includedOccurrences {\n    ...AllIsOccurrencesTree\n  }\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllVulnEqual on VulnEqual {\n  id\n  vulnerabilities {\n    ...AllVulnerabilityTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}\n\nfragment AllHasSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      ...AllBuilderTree\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n    documentRef\n  }\n}"): (typeof documents)["fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        purl\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllLicenseTree on License {\n  id\n  name\n  inline\n  listVersion\n}\n\nfragment AllVulnerabilityTree on Vulnerability {\n  id\n  type\n  vulnerabilityIDs {\n    id\n    vulnerabilityID\n  }\n}\n\nfragment AllVulnMetadataTree on VulnerabilityMetadata {\n  id\n  vulnerability {\n    id\n    type\n    vulnerabilityIDs {\n      id\n      vulnerabilityID\n    }\n  }\n  scoreType\n  scoreValue\n  timestamp\n  origin\n  collector\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependencyPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyLegalTree on CertifyLegal {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  declaredLicense\n  declaredLicenses {\n    ...AllLicenseTree\n  }\n  discoveredLicense\n  discoveredLicenses {\n    ...AllLicenseTree\n  }\n  attribution\n  justification\n  timeScanned\n  origin\n  collector\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n  knownSince\n  documentRef\n  includedSoftware {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  includedDependencies {\n    ...AllIsDependencyTree\n  }\n  includedOccurrences {\n    ...AllIsOccurrencesTree\n  }\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllVulnEqual on VulnEqual {\n  id\n  vulnerabilities {\n    ...AllVulnerabilityTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}\n\nfragment AllHasSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      ...AllBuilderTree\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n    documentRef\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestVulnEqual($vulnerability: IDorVulnerabilityInput!, $otherVulnerability: IDorVulnerabilityInput!, $vulnEqual: VulnEqualInputSpec!) {\n  ingestVulnEqual(\n    vulnerability: $vulnerability\n    otherVulnerability: $otherVulnerability\n    vulnEqual: $vulnEqual\n  )\n}\n\nmutation IngestVulnEquals($vulnerabilities: [IDorVulnerabilityInput!]!, $otherVulnerabilities: [IDorVulnerabilityInput!]!, $vulnEquals: [VulnEqualInputSpec!]!) {\n  ingestVulnEquals(\n    vulnerabilities: $vulnerabilities\n    otherVulnerabilities: $otherVulnerabilities\n    vulnEquals: $vulnEquals\n  )\n}\n\nquery VulnEquals($filter: VulnEqualSpec!) {\n  vulnEqual(vulnEqualSpec: $filter) {\n    ...AllVulnEqual\n  }\n}\n\nquery VulnEqualList($filter: VulnEqualSpec!, $after: ID, $first: Int) {\n  vulnEqualList(vulnEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnEqual\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestVulnEqual($vulnerability: IDorVulnerabilityInput!, $otherVulnerability: IDorVulnerabilityInput!, $vulnEqual: VulnEqualInputSpec!) {\n  ingestVulnEqual(\n    vulnerability: $vulnerability\n    otherVulnerability: $otherVulnerability\n    vulnEqual: $vulnEqual\n  )\n}\n\nmutation IngestVulnEquals($vulnerabilities: [IDorVulnerabilityInput!]!, $otherVulnerabilities: [IDorVulnerabilityInput!]!, $vulnEquals: [VulnEqualInputSpec!]!) {\n  ingestVulnEquals(\n    vulnerabilities: $vulnerabilities\n    otherVulnerabilities: $otherVulnerabilities\n    vulnEquals: $vulnEquals\n  )\n}\n\nquery VulnEquals($filter: VulnEqualSpec!) {\n  vulnEqual(vulnEqualSpec: $filter) {\n    ...AllVulnEqual\n  }\n}\n\nquery VulnEqualList($filter: VulnEqualSpec!, $after: ID, $first: Int) {\n  vulnEqualList(vulnEqualSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnEqual\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestVulnHasMetadata($vulnerability: IDorVulnerabilityInput!, $vulnMetadata: VulnerabilityMetadataInputSpec!) {\n  ingestVulnerabilityMetadata(\n    vulnerability: $vulnerability\n    vulnerabilityMetadata: $vulnMetadata\n  )\n}\n\nmutation IngestBulkVulnHasMetadata($vulnerabilities: [IDorVulnerabilityInput!]!, $vulnerabilityMetadataList: [VulnerabilityMetadataInputSpec!]!) {\n  ingestBulkVulnerabilityMetadata(\n    vulnerabilities: $vulnerabilities\n    vulnerabilityMetadataList: $vulnerabilityMetadataList\n  )\n}\n\nquery VulnerabilityMetadata($filter: VulnerabilityMetadataSpec!) {\n  vulnerabilityMetadata(vulnerabilityMetadataSpec: $filter) {\n    ...AllVulnMetadataTree\n  }\n}\n\nquery VulnerabilityMetadataList($filter: VulnerabilityMetadataSpec!, $after: ID, $first: Int) {\n  vulnerabilityMetadataList(\n    vulnerabilityMetadataSpec: $filter\n    after: $after\n    first: $first\n  ) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnMetadataTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestVulnHasMetadata($vulnerability: IDorVulnerabilityInput!, $vulnMetadata: VulnerabilityMetadataInputSpec!) {\n  ingestVulnerabilityMetadata(\n    vulnerability: $vulnerability\n    vulnerabilityMetadata: $vulnMetadata\n  )\n}\n\nmutation IngestBulkVulnHasMetadata($vulnerabilities: [IDorVulnerabilityInput!]!, $vulnerabilityMetadataList: [VulnerabilityMetadataInputSpec!]!) {\n  ingestBulkVulnerabilityMetadata(\n    vulnerabilities: $vulnerabilities\n    vulnerabilityMetadataList: $vulnerabilityMetadataList\n  )\n}\n\nquery VulnerabilityMetadata($filter: VulnerabilityMetadataSpec!) {\n  vulnerabilityMetadata(vulnerabilityMetadataSpec: $filter) {\n    ...AllVulnMetadataTree\n  }\n}\n\nquery VulnerabilityMetadataList($filter: VulnerabilityMetadataSpec!, $after: ID, $first: Int) {\n  vulnerabilityMetadataList(\n    vulnerabilityMetadataSpec: $filter\n    after: $after\n    first: $first\n  ) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnMetadataTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestVulnerability($vuln: IDorVulnerabilityInput!) {\n  ingestVulnerability(vuln: $vuln) {\n    vulnerabilityTypeID\n    vulnerabilityNodeID\n  }\n}\n\nmutation IngestVulnerabilities($vulns: [IDorVulnerabilityInput!]!) {\n  ingestVulnerabilities(vulns: $vulns) {\n    vulnerabilityTypeID\n    vulnerabilityNodeID\n  }\n}\n\nquery Vulnerabilities($filter: VulnerabilitySpec!) {\n  vulnerabilities(vulnSpec: $filter) {\n    ...AllVulnerabilityTree\n  }\n}\n\nquery VulnerabilityList($filter: VulnerabilitySpec!, $after: ID, $first: Int) {\n  vulnerabilityList(vulnSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnerabilityTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"): (typeof documents)["mutation IngestVulnerability($vuln: IDorVulnerabilityInput!) {\n  ingestVulnerability(vuln: $vuln) {\n    vulnerabilityTypeID\n    vulnerabilityNodeID\n  }\n}\n\nmutation IngestVulnerabilities($vulns: [IDorVulnerabilityInput!]!) {\n  ingestVulnerabilities(vulns: $vulns) {\n    vulnerabilityTypeID\n    vulnerabilityNodeID\n  }\n}\n\nquery Vulnerabilities($filter: VulnerabilitySpec!) {\n  vulnerabilities(vulnSpec: $filter) {\n    ...AllVulnerabilityTree\n  }\n}\n\nquery VulnerabilityList($filter: VulnerabilitySpec!, $after: ID, $first: Int) {\n  vulnerabilityList(vulnSpec: $filter, after: $after, first: $first) {\n    totalCount\n    edges {\n      cursor\n      node {\n        ...AllVulnerabilityTree\n      }\n    }\n    pageInfo {\n      startCursor\n      endCursor\n      hasNextPage\n    }\n  }\n}"];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;