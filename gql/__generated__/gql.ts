/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
    "mutation IngestArtifact($artifact: ArtifactInputSpec!) {\n  ingestArtifact(artifact: $artifact)\n}\n\nmutation IngestArtifacts($artifacts: [ArtifactInputSpec!]!) {\n  ingestArtifacts(artifacts: $artifacts)\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}": types.IngestArtifactDocument,
    "mutation IngestBuilder($builder: BuilderInputSpec!) {\n  ingestBuilder(builder: $builder)\n}\n\nmutation IngestBuilders($builders: [BuilderInputSpec!]!) {\n  ingestBuilders(builders: $builders)\n}": types.IngestBuilderDocument,
    "mutation CertifyBadPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadSrc($source: SourceInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadArtifact($artifact: ArtifactInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  )\n}\n\nmutation CertifyBadSrcs($sources: [SourceInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nmutation CertifyBadArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nquery CertifyBads($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}": types.CertifyBadPkgDocument,
    "mutation CertifyGoodPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodSrc($source: SourceInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodArtifact($artifact: ArtifactInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation CertifyGoodSrcs($sources: [SourceInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation CertifyGoodArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}": types.CertifyGoodPkgDocument,
    "mutation CertifyLegalPkg($pkg: PkgInputSpec!, $declaredLicenses: [LicenseInputSpec!]!, $discoveredLicenses: [LicenseInputSpec!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {package: $pkg}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation CertifyLegalPkgs($pkgs: [PkgInputSpec!]!, $declaredLicensesList: [[LicenseInputSpec!]!]!, $discoveredLicensesList: [[LicenseInputSpec!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {packages: $pkgs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nmutation CertifyLegalSrc($src: SourceInputSpec!, $declaredLicenses: [LicenseInputSpec!]!, $discoveredLicenses: [LicenseInputSpec!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {source: $src}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation CertifyLegalSrcs($srcs: [SourceInputSpec!]!, $declaredLicensesList: [[LicenseInputSpec!]!]!, $discoveredLicensesList: [[LicenseInputSpec!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {sources: $srcs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nquery CertifyLegals($filter: CertifyLegalSpec!) {\n  CertifyLegal(certifyLegalSpec: $filter) {\n    ...AllCertifyLegalTree\n  }\n}": types.CertifyLegalPkgDocument,
    "mutation CertifyScorecard($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard)\n}\n\nmutation CertifyScorecards($sources: [SourceInputSpec!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards)\n}": types.CertifyScorecardDocument,
    "mutation CertifyVexPkg($pkg: PkgInputSpec!, $vulnerability: VulnerabilityInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation CertifyVexArtifact($artifact: ArtifactInputSpec!, $vulnerability: VulnerabilityInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation CertifyVexPkgs($pkgs: [PkgInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {packages: $pkgs}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nmutation CertifyVexArtifacts($artifacts: [ArtifactInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {artifacts: $artifacts}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}": types.CertifyVexPkgDocument,
    "mutation CertifyVulnPkg($pkg: PkgInputSpec!, $vulnerability: VulnerabilityInputSpec!, $certifyVuln: ScanMetadataInput!) {\n  ingestCertifyVuln(\n    pkg: $pkg\n    vulnerability: $vulnerability\n    certifyVuln: $certifyVuln\n  )\n}\n\nmutation CertifyVulnPkgs($pkgs: [PkgInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $certifyVulns: [ScanMetadataInput!]!) {\n  ingestCertifyVulns(\n    pkgs: $pkgs\n    vulnerabilities: $vulnerabilities\n    certifyVulns: $certifyVulns\n  )\n}": types.CertifyVulnPkgDocument,
    "mutation PointOfContactPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactSrc($source: SourceInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactArtifact($artifact: ArtifactInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation PointOfContactSrcs($sources: [SourceInputSpec!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation PointOfContactArtifacts($artifacts: [ArtifactInputSpec!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}": types.PointOfContactPkgDocument,
    "mutation HasSBOMPkg($pkg: PkgInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM)\n}\n\nmutation HasSBOMArtifact($artifact: ArtifactInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {artifact: $artifact}, hasSBOM: $hasSBOM)\n}\n\nmutation HasSBOMPkgs($pkgs: [PkgInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {packages: $pkgs}, hasSBOMs: $hasSBOMs)\n}\n\nmutation HasSBOMArtifacts($artifacts: [ArtifactInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {artifacts: $artifacts}, hasSBOMs: $hasSBOMs)\n}": types.HasSbomPkgDocument,
    "mutation SLSAForArtifact($artifact: ArtifactInputSpec!, $materials: [ArtifactInputSpec!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  )\n}\n\nmutation SLSAForArtifacts($artifacts: [ArtifactInputSpec!]!, $materialsList: [[ArtifactInputSpec!]!]!, $builders: [BuilderInputSpec!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  )\n}": types.SlsaForArtifactDocument,
    "mutation IngestHasSourceAt($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $source: SourceInputSpec!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  )\n}\n\nmutation IngestHasSourceAts($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $sources: [SourceInputSpec!]!, $hasSourceAts: [HasSourceAtInputSpec!]!) {\n  ingestHasSourceAts(\n    pkgs: $pkgs\n    pkgMatchType: $pkgMatchType\n    sources: $sources\n    hasSourceAts: $hasSourceAts\n  )\n}": types.IngestHasSourceAtDocument,
    "mutation IngestHashEqual($artifact: ArtifactInputSpec!, $otherArtifact: ArtifactInputSpec!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  )\n}\n\nmutation IngestHashEquals($artifacts: [ArtifactInputSpec!]!, $otherArtifacts: [ArtifactInputSpec!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  )\n}": types.IngestHashEqualDocument,
    "mutation IsDependency($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $depPkgMatchType: MatchFlags!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(\n    pkg: $pkg\n    depPkg: $depPkg\n    depPkgMatchType: $depPkgMatchType\n    dependency: $dependency\n  )\n}\n\nmutation IsDependencies($pkgs: [PkgInputSpec!]!, $depPkgs: [PkgInputSpec!]!, $depPkgMatchType: MatchFlags!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(\n    pkgs: $pkgs\n    depPkgs: $depPkgs\n    depPkgMatchType: $depPkgMatchType\n    dependencies: $dependencies\n  )\n}": types.IsDependencyDocument,
    "mutation IsOccurrencePkg($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IsOccurrenceSrc($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IsOccurrencesPkg($pkgs: [PkgInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nmutation IsOccurrencesSrc($sources: [SourceInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}": types.IsOccurrencePkgDocument,
    "mutation IngestLicense($license: LicenseInputSpec!) {\n  ingestLicense(license: $license)\n}\n\nmutation IngestLicenses($licenses: [LicenseInputSpec!]!) {\n  ingestLicenses(licenses: $licenses)\n}\n\nquery Licenses($filter: LicenseSpec!) {\n  licenses(licenseSpec: $filter) {\n    ...AllLicenseTree\n  }\n}": types.IngestLicenseDocument,
    "mutation HasMetadataPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataSrc($source: SourceInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataArtifact($artifact: ArtifactInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation HasMetadataSrcs($sources: [SourceInputSpec!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation HasMetadataArtifacts($artifacts: [ArtifactInputSpec!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}": types.HasMetadataPkgDocument,
    "mutation IngestPackage($pkg: PkgInputSpec!) {\n  ingestPackage(pkg: $pkg)\n}\n\nmutation IngestPackages($pkgs: [PkgInputSpec!]!) {\n  ingestPackages(pkgs: $pkgs)\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n        versions {\n          id\n          version\n          qualifiers {\n            key\n            value\n          }\n          subpath\n        }\n      }\n    }\n  }\n}": types.IngestPackageDocument,
    "query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}": types.PathDocument,
    "mutation IngestPkgEqual($pkg: PkgInputSpec!, $otherPackage: PkgInputSpec!, $pkgEqual: PkgEqualInputSpec!) {\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual)\n}\n\nmutation IngestPkgEquals($pkgs: [PkgInputSpec!]!, $otherPackages: [PkgInputSpec!]!, $pkgEquals: [PkgEqualInputSpec!]!) {\n  ingestPkgEquals(\n    pkgs: $pkgs\n    otherPackages: $otherPackages\n    pkgEquals: $pkgEquals\n  )\n}": types.IngestPkgEqualDocument,
    "query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}": types.FindSoftwareDocument,
    "mutation IngestSource($source: SourceInputSpec!) {\n  ingestSource(source: $source)\n}\n\nmutation IngestSources($sources: [SourceInputSpec!]!) {\n  ingestSources(sources: $sources)\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}": types.IngestSourceDocument,
    "fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllLicenseTree on License {\n  id\n  name\n  inline\n  listVersion\n}\n\nfragment AllVulnerabilityTree on Vulnerability {\n  id\n  type\n  vulnerabilityIDs {\n    id\n    vulnerabilityID\n  }\n}\n\nfragment AllVulnMetadataTree on VulnerabilityMetadata {\n  id\n  vulnerability {\n    id\n    type\n    vulnerabilityIDs {\n      id\n      vulnerabilityID\n    }\n  }\n  scoreType\n  scoreValue\n  timestamp\n  origin\n  collector\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependencyPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  versionRange\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyLegalTree on CertifyLegal {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  declaredLicense\n  declaredLicenses {\n    ...AllLicenseTree\n  }\n  discoveredLicense\n  discoveredLicenses {\n    ...AllLicenseTree\n  }\n  attribution\n  justification\n  timeScanned\n  origin\n  collector\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n  knownSince\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllVulnEqual on VulnEqual {\n  id\n  vulnerabilities {\n    ...AllVulnerabilityTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}": types.AllPkgTreeFragmentDoc,
    "mutation IngestVulnEqual($vulnerability: VulnerabilityInputSpec!, $otherVulnerability: VulnerabilityInputSpec!, $vulnEqual: VulnEqualInputSpec!) {\n  ingestVulnEqual(\n    vulnerability: $vulnerability\n    otherVulnerability: $otherVulnerability\n    vulnEqual: $vulnEqual\n  )\n}\n\nmutation IngestVulnEquals($vulnerabilities: [VulnerabilityInputSpec!]!, $otherVulnerabilities: [VulnerabilityInputSpec!]!, $vulnEquals: [VulnEqualInputSpec!]!) {\n  ingestVulnEquals(\n    vulnerabilities: $vulnerabilities\n    otherVulnerabilities: $otherVulnerabilities\n    vulnEquals: $vulnEquals\n  )\n}": types.IngestVulnEqualDocument,
    "mutation VulnHasMetadata($vulnerability: VulnerabilityInputSpec!, $vulnMetadata: VulnerabilityMetadataInputSpec!) {\n  ingestVulnerabilityMetadata(\n    vulnerability: $vulnerability\n    vulnerabilityMetadata: $vulnMetadata\n  )\n}\n\nmutation BulkVulnHasMetadata($vulnerabilities: [VulnerabilityInputSpec!]!, $vulnerabilityMetadataList: [VulnerabilityMetadataInputSpec!]!) {\n  ingestBulkVulnerabilityMetadata(\n    vulnerabilities: $vulnerabilities\n    vulnerabilityMetadataList: $vulnerabilityMetadataList\n  )\n}": types.VulnHasMetadataDocument,
    "mutation IngestVulnerability($vuln: VulnerabilityInputSpec!) {\n  ingestVulnerability(vuln: $vuln)\n}\n\nmutation IngestVulnerabilities($vulns: [VulnerabilityInputSpec!]!) {\n  ingestVulnerabilities(vulns: $vulns)\n}\n\nquery Vulnerabilities($filter: VulnerabilitySpec!) {\n  vulnerabilities(vulnSpec: $filter) {\n    ...AllVulnerabilityTree\n  }\n}": types.IngestVulnerabilityDocument,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestArtifact($artifact: ArtifactInputSpec!) {\n  ingestArtifact(artifact: $artifact)\n}\n\nmutation IngestArtifacts($artifacts: [ArtifactInputSpec!]!) {\n  ingestArtifacts(artifacts: $artifacts)\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}"): (typeof documents)["mutation IngestArtifact($artifact: ArtifactInputSpec!) {\n  ingestArtifact(artifact: $artifact)\n}\n\nmutation IngestArtifacts($artifacts: [ArtifactInputSpec!]!) {\n  ingestArtifacts(artifacts: $artifacts)\n}\n\nquery Artifacts($filter: ArtifactSpec!) {\n  artifacts(artifactSpec: $filter) {\n    ...AllArtifactTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestBuilder($builder: BuilderInputSpec!) {\n  ingestBuilder(builder: $builder)\n}\n\nmutation IngestBuilders($builders: [BuilderInputSpec!]!) {\n  ingestBuilders(builders: $builders)\n}"): (typeof documents)["mutation IngestBuilder($builder: BuilderInputSpec!) {\n  ingestBuilder(builder: $builder)\n}\n\nmutation IngestBuilders($builders: [BuilderInputSpec!]!) {\n  ingestBuilders(builders: $builders)\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyBadPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadSrc($source: SourceInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadArtifact($artifact: ArtifactInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  )\n}\n\nmutation CertifyBadSrcs($sources: [SourceInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nmutation CertifyBadArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nquery CertifyBads($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}"): (typeof documents)["mutation CertifyBadPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadSrc($source: SourceInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadArtifact($artifact: ArtifactInputSpec!, $certifyBad: CertifyBadInputSpec!) {\n  ingestCertifyBad(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBad: $certifyBad\n  )\n}\n\nmutation CertifyBadPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyBads: $certifyBads\n  )\n}\n\nmutation CertifyBadSrcs($sources: [SourceInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nmutation CertifyBadArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {\n  ingestCertifyBads(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyBads: $certifyBads\n  )\n}\n\nquery CertifyBads($filter: CertifyBadSpec!) {\n  CertifyBad(certifyBadSpec: $filter) {\n    ...AllCertifyBad\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyGoodPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodSrc($source: SourceInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodArtifact($artifact: ArtifactInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation CertifyGoodSrcs($sources: [SourceInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation CertifyGoodArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}"): (typeof documents)["mutation CertifyGoodPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodSrc($source: SourceInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodArtifact($artifact: ArtifactInputSpec!, $certifyGood: CertifyGoodInputSpec!) {\n  ingestCertifyGood(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGood: $certifyGood\n  )\n}\n\nmutation CertifyGoodPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation CertifyGoodSrcs($sources: [SourceInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}\n\nmutation CertifyGoodArtifacts($artifacts: [ArtifactInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {\n  ingestCertifyGoods(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    certifyGoods: $certifyGoods\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyLegalPkg($pkg: PkgInputSpec!, $declaredLicenses: [LicenseInputSpec!]!, $discoveredLicenses: [LicenseInputSpec!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {package: $pkg}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation CertifyLegalPkgs($pkgs: [PkgInputSpec!]!, $declaredLicensesList: [[LicenseInputSpec!]!]!, $discoveredLicensesList: [[LicenseInputSpec!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {packages: $pkgs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nmutation CertifyLegalSrc($src: SourceInputSpec!, $declaredLicenses: [LicenseInputSpec!]!, $discoveredLicenses: [LicenseInputSpec!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {source: $src}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation CertifyLegalSrcs($srcs: [SourceInputSpec!]!, $declaredLicensesList: [[LicenseInputSpec!]!]!, $discoveredLicensesList: [[LicenseInputSpec!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {sources: $srcs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nquery CertifyLegals($filter: CertifyLegalSpec!) {\n  CertifyLegal(certifyLegalSpec: $filter) {\n    ...AllCertifyLegalTree\n  }\n}"): (typeof documents)["mutation CertifyLegalPkg($pkg: PkgInputSpec!, $declaredLicenses: [LicenseInputSpec!]!, $discoveredLicenses: [LicenseInputSpec!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {package: $pkg}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation CertifyLegalPkgs($pkgs: [PkgInputSpec!]!, $declaredLicensesList: [[LicenseInputSpec!]!]!, $discoveredLicensesList: [[LicenseInputSpec!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {packages: $pkgs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nmutation CertifyLegalSrc($src: SourceInputSpec!, $declaredLicenses: [LicenseInputSpec!]!, $discoveredLicenses: [LicenseInputSpec!]!, $legal: CertifyLegalInputSpec!) {\n  ingestCertifyLegal(\n    subject: {source: $src}\n    declaredLicenses: $declaredLicenses\n    discoveredLicenses: $discoveredLicenses\n    certifyLegal: $legal\n  )\n}\n\nmutation CertifyLegalSrcs($srcs: [SourceInputSpec!]!, $declaredLicensesList: [[LicenseInputSpec!]!]!, $discoveredLicensesList: [[LicenseInputSpec!]!]!, $legals: [CertifyLegalInputSpec!]!) {\n  ingestCertifyLegals(\n    subjects: {sources: $srcs}\n    declaredLicensesList: $declaredLicensesList\n    discoveredLicensesList: $discoveredLicensesList\n    certifyLegals: $legals\n  )\n}\n\nquery CertifyLegals($filter: CertifyLegalSpec!) {\n  CertifyLegal(certifyLegalSpec: $filter) {\n    ...AllCertifyLegalTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyScorecard($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard)\n}\n\nmutation CertifyScorecards($sources: [SourceInputSpec!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards)\n}"): (typeof documents)["mutation CertifyScorecard($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {\n  ingestScorecard(source: $source, scorecard: $scorecard)\n}\n\nmutation CertifyScorecards($sources: [SourceInputSpec!]!, $scorecards: [ScorecardInputSpec!]!) {\n  ingestScorecards(sources: $sources, scorecards: $scorecards)\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyVexPkg($pkg: PkgInputSpec!, $vulnerability: VulnerabilityInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation CertifyVexArtifact($artifact: ArtifactInputSpec!, $vulnerability: VulnerabilityInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation CertifyVexPkgs($pkgs: [PkgInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {packages: $pkgs}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nmutation CertifyVexArtifacts($artifacts: [ArtifactInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {artifacts: $artifacts}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}"): (typeof documents)["mutation CertifyVexPkg($pkg: PkgInputSpec!, $vulnerability: VulnerabilityInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {package: $pkg}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation CertifyVexArtifact($artifact: ArtifactInputSpec!, $vulnerability: VulnerabilityInputSpec!, $vexStatement: VexStatementInputSpec!) {\n  ingestVEXStatement(\n    subject: {artifact: $artifact}\n    vulnerability: $vulnerability\n    vexStatement: $vexStatement\n  )\n}\n\nmutation CertifyVexPkgs($pkgs: [PkgInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {packages: $pkgs}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}\n\nmutation CertifyVexArtifacts($artifacts: [ArtifactInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $vexStatements: [VexStatementInputSpec!]!) {\n  ingestVEXStatements(\n    subjects: {artifacts: $artifacts}\n    vulnerabilities: $vulnerabilities\n    vexStatements: $vexStatements\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CertifyVulnPkg($pkg: PkgInputSpec!, $vulnerability: VulnerabilityInputSpec!, $certifyVuln: ScanMetadataInput!) {\n  ingestCertifyVuln(\n    pkg: $pkg\n    vulnerability: $vulnerability\n    certifyVuln: $certifyVuln\n  )\n}\n\nmutation CertifyVulnPkgs($pkgs: [PkgInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $certifyVulns: [ScanMetadataInput!]!) {\n  ingestCertifyVulns(\n    pkgs: $pkgs\n    vulnerabilities: $vulnerabilities\n    certifyVulns: $certifyVulns\n  )\n}"): (typeof documents)["mutation CertifyVulnPkg($pkg: PkgInputSpec!, $vulnerability: VulnerabilityInputSpec!, $certifyVuln: ScanMetadataInput!) {\n  ingestCertifyVuln(\n    pkg: $pkg\n    vulnerability: $vulnerability\n    certifyVuln: $certifyVuln\n  )\n}\n\nmutation CertifyVulnPkgs($pkgs: [PkgInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $certifyVulns: [ScanMetadataInput!]!) {\n  ingestCertifyVulns(\n    pkgs: $pkgs\n    vulnerabilities: $vulnerabilities\n    certifyVulns: $certifyVulns\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation PointOfContactPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactSrc($source: SourceInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactArtifact($artifact: ArtifactInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation PointOfContactSrcs($sources: [SourceInputSpec!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation PointOfContactArtifacts($artifacts: [ArtifactInputSpec!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}"): (typeof documents)["mutation PointOfContactPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactSrc($source: SourceInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactArtifact($artifact: ArtifactInputSpec!, $pointOfContact: PointOfContactInputSpec!) {\n  ingestPointOfContact(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContact: $pointOfContact\n  )\n}\n\nmutation PointOfContactPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation PointOfContactSrcs($sources: [SourceInputSpec!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}\n\nmutation PointOfContactArtifacts($artifacts: [ArtifactInputSpec!]!, $pointOfContacts: [PointOfContactInputSpec!]!) {\n  ingestPointOfContacts(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    pointOfContacts: $pointOfContacts\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation HasSBOMPkg($pkg: PkgInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM)\n}\n\nmutation HasSBOMArtifact($artifact: ArtifactInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {artifact: $artifact}, hasSBOM: $hasSBOM)\n}\n\nmutation HasSBOMPkgs($pkgs: [PkgInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {packages: $pkgs}, hasSBOMs: $hasSBOMs)\n}\n\nmutation HasSBOMArtifacts($artifacts: [ArtifactInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {artifacts: $artifacts}, hasSBOMs: $hasSBOMs)\n}"): (typeof documents)["mutation HasSBOMPkg($pkg: PkgInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {package: $pkg}, hasSBOM: $hasSBOM)\n}\n\nmutation HasSBOMArtifact($artifact: ArtifactInputSpec!, $hasSBOM: HasSBOMInputSpec!) {\n  ingestHasSBOM(subject: {artifact: $artifact}, hasSBOM: $hasSBOM)\n}\n\nmutation HasSBOMPkgs($pkgs: [PkgInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {packages: $pkgs}, hasSBOMs: $hasSBOMs)\n}\n\nmutation HasSBOMArtifacts($artifacts: [ArtifactInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {\n  ingestHasSBOMs(subjects: {artifacts: $artifacts}, hasSBOMs: $hasSBOMs)\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation SLSAForArtifact($artifact: ArtifactInputSpec!, $materials: [ArtifactInputSpec!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  )\n}\n\nmutation SLSAForArtifacts($artifacts: [ArtifactInputSpec!]!, $materialsList: [[ArtifactInputSpec!]!]!, $builders: [BuilderInputSpec!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  )\n}"): (typeof documents)["mutation SLSAForArtifact($artifact: ArtifactInputSpec!, $materials: [ArtifactInputSpec!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {\n  ingestSLSA(\n    subject: $artifact\n    builtFrom: $materials\n    builtBy: $builder\n    slsa: $slsa\n  )\n}\n\nmutation SLSAForArtifacts($artifacts: [ArtifactInputSpec!]!, $materialsList: [[ArtifactInputSpec!]!]!, $builders: [BuilderInputSpec!]!, $slsaList: [SLSAInputSpec!]!) {\n  ingestSLSAs(\n    subjects: $artifacts\n    builtFromList: $materialsList\n    builtByList: $builders\n    slsaList: $slsaList\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestHasSourceAt($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $source: SourceInputSpec!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  )\n}\n\nmutation IngestHasSourceAts($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $sources: [SourceInputSpec!]!, $hasSourceAts: [HasSourceAtInputSpec!]!) {\n  ingestHasSourceAts(\n    pkgs: $pkgs\n    pkgMatchType: $pkgMatchType\n    sources: $sources\n    hasSourceAts: $hasSourceAts\n  )\n}"): (typeof documents)["mutation IngestHasSourceAt($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $source: SourceInputSpec!, $hasSourceAt: HasSourceAtInputSpec!) {\n  ingestHasSourceAt(\n    pkg: $pkg\n    pkgMatchType: $pkgMatchType\n    source: $source\n    hasSourceAt: $hasSourceAt\n  )\n}\n\nmutation IngestHasSourceAts($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $sources: [SourceInputSpec!]!, $hasSourceAts: [HasSourceAtInputSpec!]!) {\n  ingestHasSourceAts(\n    pkgs: $pkgs\n    pkgMatchType: $pkgMatchType\n    sources: $sources\n    hasSourceAts: $hasSourceAts\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestHashEqual($artifact: ArtifactInputSpec!, $otherArtifact: ArtifactInputSpec!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  )\n}\n\nmutation IngestHashEquals($artifacts: [ArtifactInputSpec!]!, $otherArtifacts: [ArtifactInputSpec!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  )\n}"): (typeof documents)["mutation IngestHashEqual($artifact: ArtifactInputSpec!, $otherArtifact: ArtifactInputSpec!, $hashEqual: HashEqualInputSpec!) {\n  ingestHashEqual(\n    artifact: $artifact\n    otherArtifact: $otherArtifact\n    hashEqual: $hashEqual\n  )\n}\n\nmutation IngestHashEquals($artifacts: [ArtifactInputSpec!]!, $otherArtifacts: [ArtifactInputSpec!]!, $hashEquals: [HashEqualInputSpec!]!) {\n  ingestHashEquals(\n    artifacts: $artifacts\n    otherArtifacts: $otherArtifacts\n    hashEquals: $hashEquals\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IsDependency($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $depPkgMatchType: MatchFlags!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(\n    pkg: $pkg\n    depPkg: $depPkg\n    depPkgMatchType: $depPkgMatchType\n    dependency: $dependency\n  )\n}\n\nmutation IsDependencies($pkgs: [PkgInputSpec!]!, $depPkgs: [PkgInputSpec!]!, $depPkgMatchType: MatchFlags!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(\n    pkgs: $pkgs\n    depPkgs: $depPkgs\n    depPkgMatchType: $depPkgMatchType\n    dependencies: $dependencies\n  )\n}"): (typeof documents)["mutation IsDependency($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $depPkgMatchType: MatchFlags!, $dependency: IsDependencyInputSpec!) {\n  ingestDependency(\n    pkg: $pkg\n    depPkg: $depPkg\n    depPkgMatchType: $depPkgMatchType\n    dependency: $dependency\n  )\n}\n\nmutation IsDependencies($pkgs: [PkgInputSpec!]!, $depPkgs: [PkgInputSpec!]!, $depPkgMatchType: MatchFlags!, $dependencies: [IsDependencyInputSpec!]!) {\n  ingestDependencies(\n    pkgs: $pkgs\n    depPkgs: $depPkgs\n    depPkgMatchType: $depPkgMatchType\n    dependencies: $dependencies\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IsOccurrencePkg($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IsOccurrenceSrc($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IsOccurrencesPkg($pkgs: [PkgInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nmutation IsOccurrencesSrc($sources: [SourceInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}"): (typeof documents)["mutation IsOccurrencePkg($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {package: $pkg}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IsOccurrenceSrc($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {\n  ingestOccurrence(\n    subject: {source: $source}\n    artifact: $artifact\n    occurrence: $occurrence\n  )\n}\n\nmutation IsOccurrencesPkg($pkgs: [PkgInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {packages: $pkgs}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}\n\nmutation IsOccurrencesSrc($sources: [SourceInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {\n  ingestOccurrences(\n    subjects: {sources: $sources}\n    artifacts: $artifacts\n    occurrences: $occurrences\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestLicense($license: LicenseInputSpec!) {\n  ingestLicense(license: $license)\n}\n\nmutation IngestLicenses($licenses: [LicenseInputSpec!]!) {\n  ingestLicenses(licenses: $licenses)\n}\n\nquery Licenses($filter: LicenseSpec!) {\n  licenses(licenseSpec: $filter) {\n    ...AllLicenseTree\n  }\n}"): (typeof documents)["mutation IngestLicense($license: LicenseInputSpec!) {\n  ingestLicense(license: $license)\n}\n\nmutation IngestLicenses($licenses: [LicenseInputSpec!]!) {\n  ingestLicenses(licenses: $licenses)\n}\n\nquery Licenses($filter: LicenseSpec!) {\n  licenses(licenseSpec: $filter) {\n    ...AllLicenseTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation HasMetadataPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataSrc($source: SourceInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataArtifact($artifact: ArtifactInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation HasMetadataSrcs($sources: [SourceInputSpec!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation HasMetadataArtifacts($artifacts: [ArtifactInputSpec!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}"): (typeof documents)["mutation HasMetadataPkg($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {package: $pkg}\n    pkgMatchType: $pkgMatchType\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataSrc($source: SourceInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {source: $source}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataArtifact($artifact: ArtifactInputSpec!, $hasMetadata: HasMetadataInputSpec!) {\n  ingestHasMetadata(\n    subject: {artifact: $artifact}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadata: $hasMetadata\n  )\n}\n\nmutation HasMetadataPkgs($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {packages: $pkgs}\n    pkgMatchType: $pkgMatchType\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation HasMetadataSrcs($sources: [SourceInputSpec!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {sources: $sources}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}\n\nmutation HasMetadataArtifacts($artifacts: [ArtifactInputSpec!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {\n  ingestBulkHasMetadata(\n    subjects: {artifacts: $artifacts}\n    pkgMatchType: {pkg: ALL_VERSIONS}\n    hasMetadataList: $hasMetadataList\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestPackage($pkg: PkgInputSpec!) {\n  ingestPackage(pkg: $pkg)\n}\n\nmutation IngestPackages($pkgs: [PkgInputSpec!]!) {\n  ingestPackages(pkgs: $pkgs)\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n        versions {\n          id\n          version\n          qualifiers {\n            key\n            value\n          }\n          subpath\n        }\n      }\n    }\n  }\n}"): (typeof documents)["mutation IngestPackage($pkg: PkgInputSpec!) {\n  ingestPackage(pkg: $pkg)\n}\n\nmutation IngestPackages($pkgs: [PkgInputSpec!]!) {\n  ingestPackages(pkgs: $pkgs)\n}\n\nquery Packages($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    ...AllPkgTree\n  }\n}\n\nquery PackageTypes($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n  }\n}\n\nquery PackageNamespaces($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n    }\n  }\n}\n\nquery PackageNames($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery PackageVersions($filter: PkgSpec!) {\n  packages(pkgSpec: $filter) {\n    id\n    type\n    namespaces {\n      id\n      namespace\n      names {\n        id\n        name\n        versions {\n          id\n          version\n          qualifiers {\n            key\n            value\n          }\n          subpath\n        }\n      }\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}"): (typeof documents)["query Path($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {\n  path(\n    subject: $subject\n    target: $target\n    maxPathLength: $maxPathLength\n    usingOnly: $usingOnly\n  ) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Neighbors($node: ID!, $usingOnly: [Edge!]!) {\n  neighbors(node: $node, usingOnly: $usingOnly) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Node($node: ID!) {\n  node(node: $node) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}\n\nquery Nodes($nodes: [ID!]!) {\n  nodes(nodes: $nodes) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on Vulnerability {\n      ...AllVulnerabilityTree\n    }\n    ... on License {\n      ...AllLicenseTree\n    }\n    ... on CertifyScorecard {\n      ...AllCertifyScorecard\n    }\n    ... on PkgEqual {\n      ...AllPkgEqual\n    }\n    ... on IsOccurrence {\n      ...AllIsOccurrencesTree\n    }\n    ... on IsDependency {\n      ...AllIsDependencyTree\n    }\n    ... on HasSLSA {\n      ...AllSLSATree\n    }\n    ... on CertifyBad {\n      ...AllCertifyBad\n    }\n    ... on CertifyGood {\n      ...AllCertifyGood\n    }\n    ... on HashEqual {\n      ...AllHashEqualTree\n    }\n    ... on HasSBOM {\n      ...AllHasSBOMTree\n    }\n    ... on HasSourceAt {\n      ...AllHasSourceAt\n    }\n    ... on PointOfContact {\n      ...AllPointOfContact\n    }\n    ... on CertifyVuln {\n      ...AllCertifyVuln\n    }\n    ... on VulnEqual {\n      ...AllVulnEqual\n    }\n    ... on CertifyVEXStatement {\n      ...AllCertifyVEXStatement\n    }\n    ... on Builder {\n      ...AllBuilderTree\n    }\n    ... on VulnerabilityMetadata {\n      ...AllVulnMetadataTree\n    }\n    ... on HasMetadata {\n      ...AllHasMetadata\n    }\n    ... on CertifyLegal {\n      ...AllCertifyLegalTree\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestPkgEqual($pkg: PkgInputSpec!, $otherPackage: PkgInputSpec!, $pkgEqual: PkgEqualInputSpec!) {\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual)\n}\n\nmutation IngestPkgEquals($pkgs: [PkgInputSpec!]!, $otherPackages: [PkgInputSpec!]!, $pkgEquals: [PkgEqualInputSpec!]!) {\n  ingestPkgEquals(\n    pkgs: $pkgs\n    otherPackages: $otherPackages\n    pkgEquals: $pkgEquals\n  )\n}"): (typeof documents)["mutation IngestPkgEqual($pkg: PkgInputSpec!, $otherPackage: PkgInputSpec!, $pkgEqual: PkgEqualInputSpec!) {\n  ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual)\n}\n\nmutation IngestPkgEquals($pkgs: [PkgInputSpec!]!, $otherPackages: [PkgInputSpec!]!, $pkgEquals: [PkgEqualInputSpec!]!) {\n  ingestPkgEquals(\n    pkgs: $pkgs\n    otherPackages: $otherPackages\n    pkgEquals: $pkgEquals\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}"): (typeof documents)["query FindSoftware($searchText: String!) {\n  findSoftware(searchText: $searchText) {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestSource($source: SourceInputSpec!) {\n  ingestSource(source: $source)\n}\n\nmutation IngestSources($sources: [SourceInputSpec!]!) {\n  ingestSources(sources: $sources)\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}"): (typeof documents)["mutation IngestSource($source: SourceInputSpec!) {\n  ingestSource(source: $source)\n}\n\nmutation IngestSources($sources: [SourceInputSpec!]!) {\n  ingestSources(sources: $sources)\n}\n\nquery Sources($filter: SourceSpec!) {\n  sources(sourceSpec: $filter) {\n    ...AllSourceTree\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllLicenseTree on License {\n  id\n  name\n  inline\n  listVersion\n}\n\nfragment AllVulnerabilityTree on Vulnerability {\n  id\n  type\n  vulnerabilityIDs {\n    id\n    vulnerabilityID\n  }\n}\n\nfragment AllVulnMetadataTree on VulnerabilityMetadata {\n  id\n  vulnerability {\n    id\n    type\n    vulnerabilityIDs {\n      id\n      vulnerabilityID\n    }\n  }\n  scoreType\n  scoreValue\n  timestamp\n  origin\n  collector\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependencyPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  versionRange\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyLegalTree on CertifyLegal {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  declaredLicense\n  declaredLicenses {\n    ...AllLicenseTree\n  }\n  discoveredLicense\n  discoveredLicenses {\n    ...AllLicenseTree\n  }\n  attribution\n  justification\n  timeScanned\n  origin\n  collector\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n  knownSince\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllVulnEqual on VulnEqual {\n  id\n  vulnerabilities {\n    ...AllVulnerabilityTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}"): (typeof documents)["fragment AllPkgTree on Package {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      versions {\n        id\n        version\n        qualifiers {\n          key\n          value\n        }\n        subpath\n      }\n    }\n  }\n}\n\nfragment AllSourceTree on Source {\n  id\n  type\n  namespaces {\n    id\n    namespace\n    names {\n      id\n      name\n      tag\n      commit\n    }\n  }\n}\n\nfragment AllArtifactTree on Artifact {\n  id\n  algorithm\n  digest\n}\n\nfragment AllBuilderTree on Builder {\n  id\n  uri\n}\n\nfragment AllLicenseTree on License {\n  id\n  name\n  inline\n  listVersion\n}\n\nfragment AllVulnerabilityTree on Vulnerability {\n  id\n  type\n  vulnerabilityIDs {\n    id\n    vulnerabilityID\n  }\n}\n\nfragment AllVulnMetadataTree on VulnerabilityMetadata {\n  id\n  vulnerability {\n    id\n    type\n    vulnerabilityIDs {\n      id\n      vulnerabilityID\n    }\n  }\n  scoreType\n  scoreValue\n  timestamp\n  origin\n  collector\n}\n\nfragment AllCertifyScorecard on CertifyScorecard {\n  id\n  source {\n    ...AllSourceTree\n  }\n  scorecard {\n    timeScanned\n    aggregateScore\n    checks {\n      check\n      score\n    }\n    scorecardVersion\n    scorecardCommit\n    origin\n    collector\n  }\n}\n\nfragment AllIsOccurrencesTree on IsOccurrence {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  artifact {\n    ...AllArtifactTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllIsDependencyTree on IsDependency {\n  id\n  justification\n  package {\n    ...AllPkgTree\n  }\n  dependencyPackage {\n    ...AllPkgTree\n  }\n  dependencyType\n  versionRange\n  origin\n  collector\n}\n\nfragment AllSLSATree on HasSLSA {\n  id\n  subject {\n    ...AllArtifactTree\n  }\n  slsa {\n    builtFrom {\n      ...AllArtifactTree\n    }\n    builtBy {\n      id\n      uri\n    }\n    buildType\n    slsaPredicate {\n      key\n      value\n    }\n    slsaVersion\n    startedOn\n    finishedOn\n    origin\n    collector\n  }\n}\n\nfragment AllCertifyLegalTree on CertifyLegal {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n  }\n  declaredLicense\n  declaredLicenses {\n    ...AllLicenseTree\n  }\n  discoveredLicense\n  discoveredLicenses {\n    ...AllLicenseTree\n  }\n  attribution\n  justification\n  timeScanned\n  origin\n  collector\n}\n\nfragment AllCertifyBad on CertifyBad {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyGood on CertifyGood {\n  id\n  justification\n  knownSince\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  origin\n  collector\n}\n\nfragment AllHashEqualTree on HashEqual {\n  id\n  justification\n  artifacts {\n    ...AllArtifactTree\n  }\n  origin\n  collector\n}\n\nfragment AllHasSBOMTree on HasSBOM {\n  id\n  subject {\n    __typename\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n    ... on Package {\n      ...AllPkgTree\n    }\n  }\n  uri\n  algorithm\n  digest\n  downloadLocation\n  origin\n  collector\n  knownSince\n}\n\nfragment AllHasSourceAt on HasSourceAt {\n  id\n  justification\n  knownSince\n  package {\n    ...AllPkgTree\n  }\n  source {\n    ...AllSourceTree\n  }\n  origin\n  collector\n}\n\nfragment AllCertifyVuln on CertifyVuln {\n  id\n  package {\n    ...AllPkgTree\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  metadata {\n    dbUri\n    dbVersion\n    scannerUri\n    scannerVersion\n    timeScanned\n    origin\n    collector\n  }\n}\n\nfragment AllPkgEqual on PkgEqual {\n  id\n  justification\n  packages {\n    ...AllPkgTree\n  }\n  origin\n  collector\n}\n\nfragment AllVulnEqual on VulnEqual {\n  id\n  vulnerabilities {\n    ...AllVulnerabilityTree\n  }\n  justification\n  origin\n  collector\n}\n\nfragment AllCertifyVEXStatement on CertifyVEXStatement {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  vulnerability {\n    ...AllVulnerabilityTree\n  }\n  status\n  vexJustification\n  statement\n  statusNotes\n  knownSince\n  origin\n  collector\n}\n\nfragment AllHasMetadata on HasMetadata {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  key\n  value\n  timestamp\n  justification\n  origin\n  collector\n}\n\nfragment AllPointOfContact on PointOfContact {\n  id\n  subject {\n    __typename\n    ... on Package {\n      ...AllPkgTree\n    }\n    ... on Source {\n      ...AllSourceTree\n    }\n    ... on Artifact {\n      ...AllArtifactTree\n    }\n  }\n  email\n  info\n  since\n  justification\n  origin\n  collector\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestVulnEqual($vulnerability: VulnerabilityInputSpec!, $otherVulnerability: VulnerabilityInputSpec!, $vulnEqual: VulnEqualInputSpec!) {\n  ingestVulnEqual(\n    vulnerability: $vulnerability\n    otherVulnerability: $otherVulnerability\n    vulnEqual: $vulnEqual\n  )\n}\n\nmutation IngestVulnEquals($vulnerabilities: [VulnerabilityInputSpec!]!, $otherVulnerabilities: [VulnerabilityInputSpec!]!, $vulnEquals: [VulnEqualInputSpec!]!) {\n  ingestVulnEquals(\n    vulnerabilities: $vulnerabilities\n    otherVulnerabilities: $otherVulnerabilities\n    vulnEquals: $vulnEquals\n  )\n}"): (typeof documents)["mutation IngestVulnEqual($vulnerability: VulnerabilityInputSpec!, $otherVulnerability: VulnerabilityInputSpec!, $vulnEqual: VulnEqualInputSpec!) {\n  ingestVulnEqual(\n    vulnerability: $vulnerability\n    otherVulnerability: $otherVulnerability\n    vulnEqual: $vulnEqual\n  )\n}\n\nmutation IngestVulnEquals($vulnerabilities: [VulnerabilityInputSpec!]!, $otherVulnerabilities: [VulnerabilityInputSpec!]!, $vulnEquals: [VulnEqualInputSpec!]!) {\n  ingestVulnEquals(\n    vulnerabilities: $vulnerabilities\n    otherVulnerabilities: $otherVulnerabilities\n    vulnEquals: $vulnEquals\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation VulnHasMetadata($vulnerability: VulnerabilityInputSpec!, $vulnMetadata: VulnerabilityMetadataInputSpec!) {\n  ingestVulnerabilityMetadata(\n    vulnerability: $vulnerability\n    vulnerabilityMetadata: $vulnMetadata\n  )\n}\n\nmutation BulkVulnHasMetadata($vulnerabilities: [VulnerabilityInputSpec!]!, $vulnerabilityMetadataList: [VulnerabilityMetadataInputSpec!]!) {\n  ingestBulkVulnerabilityMetadata(\n    vulnerabilities: $vulnerabilities\n    vulnerabilityMetadataList: $vulnerabilityMetadataList\n  )\n}"): (typeof documents)["mutation VulnHasMetadata($vulnerability: VulnerabilityInputSpec!, $vulnMetadata: VulnerabilityMetadataInputSpec!) {\n  ingestVulnerabilityMetadata(\n    vulnerability: $vulnerability\n    vulnerabilityMetadata: $vulnMetadata\n  )\n}\n\nmutation BulkVulnHasMetadata($vulnerabilities: [VulnerabilityInputSpec!]!, $vulnerabilityMetadataList: [VulnerabilityMetadataInputSpec!]!) {\n  ingestBulkVulnerabilityMetadata(\n    vulnerabilities: $vulnerabilities\n    vulnerabilityMetadataList: $vulnerabilityMetadataList\n  )\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation IngestVulnerability($vuln: VulnerabilityInputSpec!) {\n  ingestVulnerability(vuln: $vuln)\n}\n\nmutation IngestVulnerabilities($vulns: [VulnerabilityInputSpec!]!) {\n  ingestVulnerabilities(vulns: $vulns)\n}\n\nquery Vulnerabilities($filter: VulnerabilitySpec!) {\n  vulnerabilities(vulnSpec: $filter) {\n    ...AllVulnerabilityTree\n  }\n}"): (typeof documents)["mutation IngestVulnerability($vuln: VulnerabilityInputSpec!) {\n  ingestVulnerability(vuln: $vuln)\n}\n\nmutation IngestVulnerabilities($vulns: [VulnerabilityInputSpec!]!) {\n  ingestVulnerabilities(vulns: $vulns)\n}\n\nquery Vulnerabilities($filter: VulnerabilitySpec!) {\n  vulnerabilities(vulnSpec: $filter) {\n    ...AllVulnerabilityTree\n  }\n}"];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;